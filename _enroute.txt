[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

--It's relatively easy n enjoyable to review some of the classicGenerators problems. Approaches to generator problems
* p2u in next_perm
* append to each vector in a growing collection
* insert into every position in a vector in a collection

====Q[L312] 0%: Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
Looks more like math problem than algorithm problem.

array2 -- obvious decision
array3 -- With trough then I can prove we should always burst the trough
if ascending like illustrated, then I can prove the Explanation is aways optimal
if peak? Depends on the left/right. if lr > l+r+1 then should burst the peak. 

Looks like a DP idea.. any optimal substructure?

if there are 2 troughs near the ends, which one to burst or both independently?

--sol1 brute force
I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. 1 Starting node (Level n), n ending nodes (level 1).  Each node has K child or downstream nodes. This graph now suggests brute force but it might be the only way to solve the problem, like the bbg odometer.

But Level 2 has too many nodes. We need to prune the tree, from either start or end

====Q[Lv] 50%: Given array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

well-defined problem:)
greedy?
O(1) space probably means swapping
mutable?
-- My O(N) algo {applicable for any-size integers and also other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

This question is easy to search online.
====Q[c !e L]: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
====Q [c !e] next split@N boys
====Q [c !e str] longest palindrome subsequence
====Q [c] ring buffer
============= problems below should be posted to blog
