[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

====topo sort: given a directed graph, any linear algo to assign ranks?

rank table -- We can use a hashtable (or pre-sized vector) to store the ranks: {rank -> list of nodes of that rank}. Assigning a node means adding the node id to the correct list, in O(1)

Assumption 1: the original graph nodes contain uplinks but no downlinks. spreadsheet-model.

Assumption 2: the original graph nodes contain downlinks but no uplinks. I think this is Kahn's assumption, like notification call list

In most situations, One of these two assumptions would hold, but rarely both.

Scan-1 O(V+E) -- build a hashtable-based two-way edgeSet representation of the graph. For each node, we maintain a hashset of uplinks and a hashset of downlinks. The duplication is needed, based on my knowledge. However, Kahn's algo uses only the original one-way links.

Scan-2 O(V) -- assign rank 0 to all top-level nodes (no uplink). Now we can use the rank table to scan rank-0 nodes

Scan-3 -- Now scan the last assigned rank, rank-0 in this case. For each node in that list, check each downstream child. Unconditionally remove (O(1) thanks to hashset) the uplink from inside the child. After that, If the child has empty hashset of uplinks it is assigned rank 1. I now believe the uplink/downlink is never accessed again, so we can remove both.

Repeat the last scan.

Every node is assigned only once. Every edge is checked only once or twice.

In this design, I use multiple simple passes and avoid doing too much in one pass. If needed, you can combine Scan-2 and Scan-1.

We treat the original nodes as readonly.

Can the uplinks hashset become an integer count?
====Q [c str] longest palindrome subsequence (not subarray)
if there's an elegant idea then I should try then read it. 

To keep things simple just assume there are only 3 unique chars

Can we safely remove some char to reduce the problem to a smaller problem?

I feel there should be some DP solution as a shorter haystack is definitely easier than a longer haystack

----DP idea 2 (efficiency is decent but clarity is outstanding) 
At each position i in the haystack string, we keep a Club of .... "Members" each a palindrome subseq ending at i. 
Requirement: Every eligible Member must be in the Club. 

For the next position after incrementing i once, this DP algo builds the new Club using earlier Clubs. We look at each [4] Member in each earlier Club. All of these Members are unique by construction :) Member is a COW class, having 
* an immutable length
* an immutable "seq" array of subscripts representing the subseq -- no two Members have identical seq contents. The last array element is implicitly i
* an immutable hashtable (or array) of "unused chars on my left". Each entry is {unused char -> stack of positions}. Note this stack is natually sorted.
This local optimizatino eliminates the expensive backscan.

The Club is immutable. Conceptually, there's no reason to modify a Club once constructed.

What do we do when we examine a Member? If a Member can "grow" (righward or both ways) to use the new char, then this Member clones itself, grows and joins the new Club. The "growth" shall update the hashtable if growing both ways.

The new char itself is automatically a (trivial) Member of this new Club. Crucially, this is how a new palindrome subsequence gets created.

At any time, before i++, the latest constructed Club includes all the palindrome subseq ending at i. 
Similar invariants hold for earlier Clubs. 
This level of complete control is kinda remarkable, thanks to the elegance of this dP algorithm.

--[4] An implementation trick -- The default implementation would examine every known Member but we can be lazier. As we increment i, we will focus on Group-6 i.e. the leading pack of longest Members, all length 6, across all Clubs. One Group-6 Member might keep growing 15 steps where there are only 15 chars on the forward scan. In such a case, this Member can safely be declared the winner, without looking at the "other" Groups

In fact, I might pick one length-6 Member. But if this pick stops growing, then I pick another from the leading pack... backtracking? IFF all of Group-6 stop growing, then we look at Group-5.

I feel this may not work so well, since there's a high chance that some group-1 Member has the best potential. The current length of a Member is not a good predictor of ultimate lengh. 
----DP idea 1
as we increment a forward marker, we keep all growers.

Each grower keeps a hashtable (or array) of "unused chars on my left". Each entry is {unused char -> sorted stack of positions}. This eliminates the expensive backscan

Grower class is kinda copy-on-write. Once it sees it can grow (on both ends), it would remember which pos (on its left) then clone itself (incl hashtable) and then updates its hashtable.

As we increment the iterator, we focus on group 6 i.e. the leading pack of longest growers, all length 6. [1] In fact, I might pick one length-6 grower [2]. IFF all of group-6 stop growing, then we look at group-5.

[1] as one length-6 grower may keep growing 15 steps assuming there are only 15 chars on the forward scan. In such a case, this grower can safely be declared the winner, without looking at the "other packs"

[2] if this pick stops growing, then I pick another from the leading pack... backtracking?

If this works it is again using auxDS, my strength

====Q[c e v] implement half-written abbr_iterative.h based on the abbr_ascendRecursive.h
Not so easy when the word contains dupe letters. I think hashtable is simplest solution in a realistic context, as explained in cookbook.py
