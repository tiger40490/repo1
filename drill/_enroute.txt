[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

====Q [c DP] given the first N natural numbers, how many BST can you form?
how do you make use of the previous results for N=2 to tackle N=3?
N=2: ans=2
N=3: need to draw them to see patterns

====Q [c str] longest palindrome subsequence (not subarray)
if there's an elegant idea then I should try then read it. 

To keep things simple just assume there are only 3 unique chars

Can we safely remove some char to reduce the problem to a smaller problem?

I feel there should be some DP solution as a shorter haystack is definitely easier than a longer haystack

--DP idea 2 (efficiency is decent but clarity is outstanding) 
At each position i in the haystack string, we keep a club of Members each a palindrome subseq ending at i. 

For the next position, this DP algo builds the new club using earlier clubs. We look at each member in each earlier club. All of these members are unique by construction :) 

Member is a COW class, having an array of subscripts representing the subseq, and also a hashtable (or array) of "unused chars on my left". Each entry is {unused char -> sorted stack of positions}. This eliminates the expensive backscan.

If a member can "grow" to use the new char, then this member clones itself, grows and joins the new club. The "growth" shall update the hashtable if growing both ways.

The new char itself is automatically a (trivial) member of this new club.

--DP idea 1
as we increment a forward marker, we keep all growers.

Each grower keeps a hashtable (or array) of "unused chars on my left". Each entry is {unused char -> sorted stack of positions}. This eliminates the expensive backscan

Grower class is kinda copy-on-write. Once it sees it can grow (on both ends), it would remember which pos (on its left) then clone itself (incl hashtable) and then updates its hashtable.

As we increment the iterator, we focus on group 6 i.e. the leading pack of longest growers, all length 6. [1] In fact, I might pick one length-6 grower [2]. IFF all of group-6 stop growing, then we look at group-5.

[1] as one length-6 grower may keep growing 15 steps assuming there are only 15 chars on the forward scan. In such a case, this grower can safely be declared the winner, without looking at the "other packs"

[2] if this pick stops growing, then I pick another from the leading pack... backtracking?

If this works it is again using auxDS, my strength

====Q[c e v] implement half-written abbr_iterative.h based on the abbr_ascendRecursive.h
Not so easy when the word contains dupe letters. I think hashtable is simplest solution in a realistic context, as explained in cookbook.py
