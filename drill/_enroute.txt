[c=classic]
[e=ez]
[cc=careercup]
[L=leetcode]
[o=original, not discussed widely]
[v=easy to verify]

====[eL] Q: Given a binary tree, determine if it is height-balanced -- a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

I can try it on Leetcode .. no need to set up test harness myself but I might be frustrated

-- post-order walk? 

-- How about a simple recursive algo
for any node, find the its subtree height including itself and return it. Before returning, also compare the left vs right subtree heights

====Q: Given a list of loans {lenderId, borrowerId, amt}, write a repay(loans) to produce the minimum set of repayments.
Eg: {B>A,$3} {A>C,$1} {C>B,$2} means ultimately A received $2, B lent $1, C lent $1.

Each person gets an account with a final balance. Some (say 22) accounts are positive, while the rest (say 11) negative. 

To really clean up, it's good to identify disjoint groups of persons. Within each group, settle.

what's the exact requirement? Better ask Rahul
====Q: within a matrix (recombinant tree) generate all paths from [0,0] to [A,B]. Each step must go down
A+B steps in total. Among them, A steps must move south-east.

A+B_choose_A paths?

To generate the paths, start with the "abbr/combo" algo.
====Q from p 183  [[discrete math]]: given a n x n grid. Start from north west corner moving south or east each step, towards that corner. The diagonal connecting them can be touched from north, but not crossed. print all paths

easier to treat origin as [0,0] and end as [N,N]

DFT will require deep recursion. 
BFT (with color) where each node remembers all paths-from-root? Kinda brute force 
How about DP bottom-up? Not good
--iterative
no need to navigate the grid. Just generate from a formula
Each path has 2N steps, but on any partial path the southward steps must not exceed eastward steps. 
Make 2N decisions. Be greedy on southward?

====Q (classic DP problem, not contrived): optimal bst: 
Given a set of sorted search keys and their hit probabilities, construct the BST with lowest search cost. 
we know the probabilities add up to 100%. 
There are many ways to construct a BST (I solved that problem, shared by Rahul), but the search cost is different, defined as

sum of {depth of key_i * probability of key_i}

Can we put the busiest key as root? But what if it is the first/last key?

====[o]Q: maximize sum+dist. Given an array of signed ints. The score of any pair is their sum + their distance(i.e. subscript diff). Find the best pair.
I will call the best pair "left winner" and "right winner"

----
I don't know where this problem comes from. Don't know where to search for solution..Good.. but then i found https://stackoverflow.com/questions/32067492/maximize-sum-distance-for-integer-array is the same problem.

int-array problem is my relative weakness. O(NN) is simple but I think we can achieve O(N) with multiple scans.

How about two-pointers moving in?
How about two-pointers moving forward?

99 88 3 2 3 5 7 5 9< 4 2
88 99 2 3 5 1 6 3 6 0 1 2 3 
3 2 1 5 3 2 9 3 1 0 2 6 3 2
1 0 2 8 6 3 1 7 5 1 4

What if the first elements are 11,12,13,14? They are equally good as the left winner or they all lose to another item on the right
====Q (60%): given a signed-int array, find the longest subarray having sum=K

First scan to build cumulative sum -- the sum-array. Looks like a price chart. First value is the first original element.

Now scan the sum array. At each element s[j], I save s[j] in hashtable {s[j] -> j] only if no such key yet. 

I look for the earliest element s[i] such that s[i] + K == s[j]. If found in the hash table, then compute j-i and update the global best if necessary.

Note the hash table's values are all earlier than j, since we are scanning forward.

Can consolidate to one scan.
====Q: max distance: Given an array A of integers, find the maximum of j - i, subjected to the constraint of A[i] <= A[j].
Practical scenario -- given a pricing time series, find the "best" buy-sell trade with longest hold, because you want to have some exposure for as long as possible.
Example: Input A: [3, 5, 4, 2]. Output: 2 for the pair (3, 4)

Sugg{ moving and expanding window?
Sugg: How about line sweep?

build a RbTree ordered by price-then-timestamp. The tree will have exactly N tree nodes even though prices are non-unique. In each tree node implicit payload is "my timestamp".

--Jargon -- 
Better prices are to the right on the treemap; (Can draw the price chart downward)
Earlier timestamps are invisible on the treemap;
up-the-tree is not visible on the chart and not important

--idea 1 Single fwd scan
invariant -- at any moment during the fwd scan, each tree node records "earliest price point that's same or worse than me".

Initial payload at each tree node -- next-better tree-node

After inserting a node on the tree, i look for the "neighbor" tree node defined as a node of same-price (pick earliest) or next-better-price (pick earliest). 
If neighbor has a payload, duplicate that payload.
After updating the payload, compute the "hold" time -- from the payload value (an earlier timestamp) to my timestamp. if this new hold time is longer than a global "longest hold", then update the global variable.

Trivial scenario -- If the neighbor doesn't exist, then the payload is my own timestamp
