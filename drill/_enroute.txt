[c=classic]
[e=ez]
[cc=careercup]
[L=leetcode]
[o=original, not discussed widely]
[v=easy to verify]

====Q: Given a list of loans {lenderId, borrowerId, amt}, write a repay(loans) to produce the minimum set of repayments.
Eg: {B>A,$3} {A>C,$1} {C>B,$2} means ultimately A received $2, B lent $1, C lent $1.

Each person gets an account with a final balance. Some (say 22) accounts are positive, while the rest (say 11) negative. 

To really clean up, it's good to identify disjoint groups of persons. Within each group, settle.

what's the exact requirement? Better search on leetcode

====Q from p 183  [[discrete math]]: given a n x n grid. Start from north west corner moving south or east each step, towards that corner. The diagonal connecting them can be touched from north, but not crossed. print all paths

Not relevant to FB interview

easier to treat origin as [0,0] and end as [N,N]

DFT will require deep recursion. 
BFT (with color) where each node remembers all paths-from-root? Kinda brute force 
How about DP bottom-up? Not attractive
--iterative
no need to navigate the grid. Just generate from a formula
Each path has 2N steps, but on any partial path the southward steps must not exceed eastward steps. 

Just use the abbr/combo algo and add a constraint

Make 2N decisions. Be greedy on southward?


====Q: max distance: Given an array A of integers, find the maximum of j - i, subjected to the constraint of A[i] <= A[j].
Practical scenario -- given a pricing time series, find the "best" buy-sell trade with longest hold, because you want to have some exposure for as long as possible, perhaps as a hedge or for compliance (frequent-trading is penalized). Some hedge funds and IPO placement have lock-in periods.
Example: Input A: [3, 5, 4, 2]. Output: 2 for the pair (3, 4)

Sugg{ moving and expanding window?
Sugg: How about line sweep (Rahul's solution..)?

build a RbTree ordered by price-then-timestamp. The tree will have exactly N tree nodes even though prices are non-unique. In each tree node implicit payload is "my timestamp".

--O(N) solution using two shadow arrays
min-from-earliest
max-from-latest

two curves. As we sweep a horizontal line up, just keep track of the 2 intersections. I think the longest distance btw is the answer.

--Jargon -- 
Better prices are to the right on the treemap; (Can draw the price chart downward)
Earlier timestamps are invisible on the treemap;
up-the-tree is not visible on the chart and not important

--idea 1 Single fwd scan
invariant -- at any moment during the fwd scan, each tree node records "earliest price point that's same or worse than me".

Initial payload at each tree node -- next-better tree-node

After inserting a node on the tree, i look for the "neighbor" tree node defined as a node of same-price (pick earliest) or next-better-price (pick earliest). 
If neighbor has a payload, duplicate that payload.
After updating the payload, compute the "hold" time -- from the payload value (an earlier timestamp) to my timestamp. if this new hold time is longer than a global "longest hold", then update the global variable.

Trivial scenario -- If the neighbor doesn't exist, then the payload is my own timestamp
