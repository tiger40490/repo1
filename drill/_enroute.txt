[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]


====topo sort: given a directed graph, any linear algo to assign ranks?

====Q: a slist has one more link field in each node. It's the address of a random node in the same slist. How do you serialize this linked list?

I think the generic solution works but there is hopefully a more intuitive one -- assign id to each new node in the first scan. 

first scan to traverse slist and visit all nodes. 

writing to file is only in 2nd scan:

2nd scan visits each node to save the random field along with the host node id

--alternatively


====Q [c DP] given the first N natural numbers, how many BST can you form?
how do you make use of the previous results for N=2 to tackle N=3?
f(z) denotes count of unique BSTs consisting of the fist z natural number
f(0)=f(1)=1

* for odd z, express it as z:=2y+1 where y > 0 
f(2y+1)=[ f(a=0)*f(2y) + f(a=1)f(2y-1) + f(2)f(2y-2)... +f(y-1)f(y+1) ]*2 + f(y)f(y)

Note a should increment from 0 up to y-1.

* for even z, express it as z:=2y where y > 0
f(2y)=[ f(0)*f(2y-1) + f(1)f(2y-2) + f(2)f(2y-3)... +f(y-1)f(y) ]*2

Let's try this formula on f(2)...= 2 good
Let's try this formula on f(3)...=5 y=1

--N=3: 
if 1 is root, then there are f(2) BSTs
if 3 is root, then there are f(2) BSTs
if 2 is root, then there are f(1) * f(1) BSTs
--N=9:
if 1 is root, there are f(8) BSTs
if 9 is root, there are f(8) BSTs
if 4 is root, there are f(3) left-subtrees and f(5) right-subtrees, giving f(3)*f(5) BSTs

This is not coding challenge but math challenge. 

Q2: output all BSTs. We need a way to represent (serialize) a BST?
====Q [c str] longest palindrome subsequence (not subarray)
if there's an elegant idea then I should try then read it. 

To keep things simple just assume there are only 3 unique chars

Can we safely remove some char to reduce the problem to a smaller problem?

I feel there should be some DP solution as a shorter haystack is definitely easier than a longer haystack

----DP idea 2 (efficiency is decent but clarity is outstanding) 
At each position i in the haystack string, we keep a Club of .... "Members" each a palindrome subseq ending at i. 
Requirement: Every eligible Member must be in the Club. 

For the next position after incrementing i once, this DP algo builds the new Club using earlier Clubs. We look at each [4] Member in each earlier Club. All of these Members are unique by construction :) Member is a COW class, having 
* an immutable length
* an immutable "seq" array of subscripts representing the subseq -- no two Members have identical seq contents. The last array element is implicitly i
* an immutable hashtable (or array) of "unused chars on my left". Each entry is {unused char -> stack of positions}. Note this stack is natually sorted.
This local optimizatino eliminates the expensive backscan.

The Club is immutable. Conceptually, there's no reason to modify a Club once constructed.

What do we do when we examine a Member? If a Member can "grow" (righward or both ways) to use the new char, then this Member clones itself, grows and joins the new Club. The "growth" shall update the hashtable if growing both ways.

The new char itself is automatically a (trivial) Member of this new Club. Crucially, this is how a new palindrome subsequence gets created.

At any time, before i++, the latest constructed Club includes all the palindrome subseq ending at i. 
Similar invariants hold for earlier Clubs. 
This level of complete control is kinda remarkable, thanks to the elegance of this dP algorithm.

--[4] An implementation trick -- The default implementation would examine every known Member but we can be lazier. As we increment i, we will focus on Group-6 i.e. the leading pack of longest Members, all length 6, across all Clubs. One Group-6 Member might keep growing 15 steps where there are only 15 chars on the forward scan. In such a case, this Member can safely be declared the winner, without looking at the "other" Groups

In fact, I might pick one length-6 Member. But if this pick stops growing, then I pick another from the leading pack... backtracking? IFF all of Group-6 stop growing, then we look at Group-5.

I feel this may not work so well, since there's a high chance that some group-1 Member has the best potential. The current length of a Member is not a good predictor of ultimate lengh. 
----DP idea 1
as we increment a forward marker, we keep all growers.

Each grower keeps a hashtable (or array) of "unused chars on my left". Each entry is {unused char -> sorted stack of positions}. This eliminates the expensive backscan

Grower class is kinda copy-on-write. Once it sees it can grow (on both ends), it would remember which pos (on its left) then clone itself (incl hashtable) and then updates its hashtable.

As we increment the iterator, we focus on group 6 i.e. the leading pack of longest growers, all length 6. [1] In fact, I might pick one length-6 grower [2]. IFF all of group-6 stop growing, then we look at group-5.

[1] as one length-6 grower may keep growing 15 steps assuming there are only 15 chars on the forward scan. In such a case, this grower can safely be declared the winner, without looking at the "other packs"

[2] if this pick stops growing, then I pick another from the leading pack... backtracking?

If this works it is again using auxDS, my strength

====Q[c e v] implement half-written abbr_iterative.h based on the abbr_ascendRecursive.h
Not so easy when the word contains dupe letters. I think hashtable is simplest solution in a realistic context, as explained in cookbook.py
