[c=classic]
[e=ez]
[cc=careercup]
[L=leetcode]
[o=original, not discussed widely]
[v=easy to verify]

====[eL] Q: Given a binary tree, determine if it is height-balanced -- a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

I can try it on Leetcode .. no need to set up test harness myself but I might be frustrated

-- post-order walk? 

-- How about a simple recursive algo
for any node, find the its subtree height including itself and return it. Before returning, also compare the left vs right subtree heights

====Q: Given a list of loans {lenderId, borrowerId, amt}, write a repay(loans) to produce the minimum set of repayments.
Eg: {B>A,$3} {A>C,$1} {C>B,$2} means ultimately A received $2, B lent $1, C lent $1.

Each person gets an account with a final balance. Some (say 22) accounts are positive, while the rest (say 11) negative. 

To really clean up, it's good to identify disjoint groups of persons. Within each group, settle.

what's the exact requirement? Better ask Rahul
====Q: within a matrix (recombinant tree) generate all paths from [0,0] to [A,B]. Each step must go down
A+B steps in total. Among them, A steps must move south-east.

A+B_choose_A paths?

To generate the paths, start with the "abbr/combo" algo.
====Q from p 183  [[discrete math]]: given a n x n grid. Start from north west corner moving south or east each step, towards that corner. The diagonal connecting them can be touched from north, but not crossed. print all paths

easier to treat origin as [0,0] and end as [N,N]

DFT will require deep recursion. 
BFT (with color) where each node remembers all paths-from-root? Kinda brute force 
How about DP bottom-up? Not good
--iterative
no need to navigate the grid. Just generate from a formula
Each path has 2N steps, but on any partial path the southward steps must not exceed eastward steps. 
Make 2N decisions. Be greedy on southward?

====Q (classic DP problem, not contrived): optimal bst: 
Given a set of sorted search keys and their hit probabilities, construct the BST with lowest search cost. 
we know the probabilities add up to 100%. 
There are many ways to construct a BST (I solved that problem, shared by Rahul), but the search cost is different, defined as

sum of {depth of key_i * probability of key_i}

Can we put the busiest key as root? But what if it is the first/last key?

====[o]Q: maximize sum+dist. Given an array of signed ints. The score of any pair is their sum + their distance(i.e. subscript diff). Find the best pair.
I will call the best pair "left winner" and "right winner"

----
I don't know where this problem comes from. Don't know where to search for solution..Good.. but then i found https://stackoverflow.com/questions/32067492/maximize-sum-distance-for-integer-array is the same problem.

int-array problem is my relative weakness. O(NN) is simple but I think we can achieve O(N) with multiple scans.

How about two-pointers moving in?
How about two-pointers moving forward?

99 88 3 2 3 5 7 5 9< 4 2
88 99 2 3 5 1 6 3 6 0 1 2 3 
3 2 1 5 3 2 9 3 1 0 2 6 3 2
1 0 2 8 6 3 1 7 5 1 4

What if the first elements are 11,12,13,14? They are equally good as the left winner or they all lose to another item on the right
====Q: max distance: Given an array A of integers, find the maximum of j - i, subjected to the constraint of A[i] <= A[j].
Practical scenario -- given a pricing time series, find the "best" buy-sell trade with longest hold, because you want to have some exposure for as long as possible.
Example: Input A: [3, 5, 4, 2]. Output: 2 for the pair (3, 4)

Sugg{ moving and expanding window?
Sugg: How about line sweep?

build a RbTree keyed by prices, but holding the timestamps as payload.
--Jargon -- 
Better prices are to the right on the treemap; (Can draw the chart downward)
Earlier timestamps are invisible on the treemap;
up-the-tree is not visible on the chart
--idea 1
each tree node records "earliest time that's worst than me"

If this can be achieved efficiently, then we can scan the tree one more time. At each node compute the "span" of that price level.
--idea 2
each tree node records the earlier of (own timestamp, the next worse node timestamp)

Outer scan -- scan from final timestamp to earliest timestamp and insert on treemap. When inserting a node, the "next-better" node gets updated with the new timestamp

One final tree walk from greatest price (right-most) node. At each node, 