[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]
 
====Q [c DP] from Rahul
Given longer and short strings Haystack vs Needle, can string-N match a sub-sequence (not necessarily substring) of string-H? You can say we are checking if string-N is hiding in string-H. If yes how many hiding places or sub-sequences can you find? 

More formally, if length of string-N is 5, then each hiding place is a tuple of 5 subscripts into string-H...

Eg: H = GeeksForGeeks; N = Gks. Answer is 4 subsequences

My idea is backtracking recursion with memoization, hopefully O(len(H) * len(N))

====Q [c DP] LCS: longest common subsequence (not sub-string) between two strings X and Y
classic DP problem.

Let's suppose there are 10 chars in X, 10 in Y
abcbcfgbac = Y
acebgfacbc = X

--top-down algo
Treat X as haystack and search for Y[0]. If found at X[3], then recursively call f(X[4:], Y[1:]). After this function returns or if not found, iterate to Y[1]. This loop only looks for Y[0] in X.

Then treat Y as haystack

--bottom-up approach is not even half done:
lcs(X[0:1], Y) left-most match in Y .. returns the lowest index in Y to accommodate the shorter string, or -1 for failure
.. can be easily completed
lcs(Y[0:1], X) can be easily completed
lcs(X[0:2], Y): given the lcs(X[0:1], Y) answer, we scan (Y) forward from there 

====Q [c DP] knapsack problem: we are given a set of n items, where each item i is specified by a size s[i] and a value v[i]. We are also given a size bound S (the size of our knapsack). The optimization goal is to find the subset of items of maximum total value such that sum of their sizes is at most S (they all fit into the knapsack)

classic DP problem.

f(remainingItems, remainingCapacity) is the basic function to write.

I would want to sort the items by "density" of gold, so i always take the densest item unless it doesn't fit

====Q [c str] longest palindrome subsequence (not subarray)
If there's an elegant idea then I should try then read it. Syntax should be light.
I think some non-optimal solution is feasible. start with some good (extreme) examples
eg alabama -> aabaa
eg mississippi -> ississi
eg philippines -> pilip

To keep things simple just assume there are only 26 chars

Can we safely remove some char to reduce the problem to a smaller problem?

--solution 1 (not so good): classic generator for all abbr and check each but at some point we may have enough confidence to terminate the search
=====Q (Deepak 2019) tough matrix problem: 
given a black/white but mostly white matrix, for each cell, compute the least horizontal/vertical steps (shortest distance) to a black cell.

Given a Matrix with 1's and very few 0's, replace all the 1's in the matrix with the adjacent distance to nearest 0. There can be more than one '0' in the matrix
Ex : Input: //Matrix contains more than one '0'
Matrix = {      1, 1, 1, 1, 1,
                1, 1, 1, 1, 1,
                0, 1, 0, 1, 1,
                1, 1, 1, 1, 1,
                1, 1, 0, 1, 1 };
Output = {      2, 3, 2, 3, 4,
                1, 2, 1, 2, 3,
                0, 1, 0, 1, 2,
                1, 2, 1, 2, 3,
                2, 1, 0, 1, 2 }

The Original question that was asked in the Interview was simpler. The actual question was given a Matrix, replaces all 1's with distance form the Element that contains 0. In this problem there is only One '0' in the Matrix.

Input : //Matrix contains exactly One '0'
Matrix = {      1, 0, 1, 1,
                1, 1, 1, 1,
                1, 1, 1, 1,
                1, 1, 1, 1 }
Output = {       1, 0, 1, 2,
                 2, 1, 2, 1,
                 1, 2, 3, 4,
                 4, 3, 4, 5 };
		   
NOTE : Only Adjacent distance is to be calculated, not Diagonal. 
-------------------
Theoretical limit: O(N)

suppose there are W white cells.

if we know for sure the scores in four neighbors, then it's O(1) to work out my score.

which cells have known scores? those next to the whites.

--idea 3 (frontier):
Does this algo work with any graph?
Hope to simplify it to improve clarify and correctness
What if the white cells are on the perimeter and the frontier shrinks?
How would two frontiers join?

initial-scan #0a to initialize all non-white locations to -1 (indicating "green"). Save the number of greens in a "greenCount"
initial-Scan #0b to collect all white locations. For each white location F with some green neighbor, saves F in a "frontier" collection, perhaps a linked list. 

Also create an empty "new frontier" collection.

The initial scans can be combined but at the cost of simplicity.

Invariants before a subsequent update-scan -- 
* Every frontier location has some green neighbor. 
* new frontier collection is empty. 
* greenCount is updated.

update-scan #1 update each adjacent green location to the frontier. Set score to 1, finalized and no longer green. iif a finalized location F has a green neighbor, then save F in the new frontier collection. 

After the scan, assert the new and old frontier collections have no overlap. Now swap old and new frontier collections and clear the new collection. 

update-scan #2 for each location in the frontier, update adjacent green locations to 2, finalized and no longer green. If such a finalized location F has a green neighbor, then save F in the new frontier collection. 

Green count should now reduce. When it becomes 0 we are done.

big-O? At each scan, the new frontier is usually larger than the old frontier until an inflection point. If before each update-scan we keep a count of the frontier collection size, i think they won't add up to exceed N. Therefore, total complexity is O(N) provided the fanout is a constant like 4. If fanout is unlimited, then possibly O(V+E) since we visit each node and each ege up to 3 times.

--idea 2 (shells):
scan #1 to save all white cell locations, and save all black cell locations in a shadow matrix (bool shadow matrix of the same size as original matrix) and a blacklist (hashtable indexed by cell location)
For each while, compute distance to center. At end of this scan, designte one whte cell as red i.e. closest to center.

scan #1b[O(N)] update all black cells with d2red. Now we have some baseline values, to be improved
scan #2 [O(W)] for each white, update all cells around it with distance 1. Remove the updated cells from the "blacklist"

Also set the bool in the shadow matrix

Scan #3 for each white, update the 2nd shell

details?

If a black cell is updated by 5 white cells in the same iteration, then all 5 whites would be equally distant, so the first of them would remove the black cell from blacklist.

So each black cell is only updated once .. O(N)?

--idea 1 (DP):
Scan#1 from top and left, update each cell with a "TL score" i.e. shortest dist ignoring the Bottom-Right quadrant of cells i.e. cells right-and-lower of current.

consider a typical cell on 2nd row. what's tl score? Can compute using upper and left neighbors? will it ignore a white on the right?

Scan#2 from bottom right, to compute a BR score for each cell

Scan#3 (can be part of Scan#2) combine the data

Rationale -- for each white cell, the shortest path can be in either BR quadrant (Scan2) or (Scan1) the other 3 quadrants. 

====Q [c !e] next split@N boys
============= problems below should be posted to blog
