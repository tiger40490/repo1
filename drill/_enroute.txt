[c=classic]
[e=ez]
[cc=careercup]
[L=leetcode]
[o=original, not discussed widely]
[v=easy to verify]

==Q: detect cycle in bintree
dft.. use a stack to keep the current path. I may have this code in github

bft. Each node keeps a parent-node-set, represented by hash table

====Q: given any tree, print the (height of the subtree) at every node. Also print the node address just for identification

dft with level?

====[eL] Q: Given a binary tree, determine if it is height-balanced -- a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

I can try it on Leetcode .. no need to set up test harness myself but I might be frustrated

-- post-order walk? 

-- How about a simple recursive algo
for any node, find the its subtree height including itself and return it. Before returning, also compare the left vs right subtree heights

====Q: Given a list of loans {lenderId, borrowerId, amt}, write a repay(loans) to produce the minimum set of repayments.
Eg: {B>A,$3} {A>C,$1} {C>B,$2} means ultimately A received $2, B lent $1, C lent $1.

Each person gets an account with a final balance. Some (say 22) accounts are positive, while the rest (say 11) negative. 

To really clean up, it's good to identify disjoint groups of persons. Within each group, settle.

what's the exact requirement? Better ask Rahul
====Q: within a matrix (recombinant tree) generate all paths from [0,0] to [A,B]. Each step must go down
A+B steps in total. Among them, A steps must move south-east.

A+B_choose_A paths?

To generate the paths, start with the "abbr/combo" algo.
====Q from p 183  [[discrete math]]: given a n x n grid. Start from north west corner moving south or east each step, towards that corner. The diagonal connecting them can be touched from north, but not crossed. print all paths

easier to treat origin as [0,0] and end as [N,N]

DFT will require deep recursion. 
BFT (with color) where each node remembers all paths-from-root? Kinda brute force 
How about DP bottom-up? Not good
--iterative
no need to navigate the grid. Just generate from a formula
Each path has 2N steps, but on any partial path the southward steps must not exceed eastward steps. 
Make 2N decisions. Be greedy on southward?

====Q (classic DP problem, not contrived): optimal bst: 
Given a set of sorted search keys and their hit probabilities, construct the BST with lowest search cost. 
we know the probabilities add up to 100%. 
There are many ways to construct a BST (I solved that problem, shared by Rahul), but the search cost is different, defined as

sum of {depth of key_i * probability of key_i}

Can we put the busiest key as root? But what if it is the first/last key?

====[o]Q: maximize sum+dist. Given an array of signed ints. The score of any pair is their sum + their distance(i.e. subscript diff). Find the best pair.
I will call the best pair "left winner" and "right winner"

----
I don't know where this problem comes from. Don't know where to search for solution..Good.. but then i found https://stackoverflow.com/questions/32067492/maximize-sum-distance-for-integer-array is the same problem.

int-array problem is my relative weakness. O(NN) is simple but I think we can achieve O(N) with multiple scans.
--my solution
scan forward to build a shadow array of "left scores" for each element s[i]:= a[i] - i. If a[i] were to increase by 1, the score would also improve by 1...

Scan backward to build a shadow array of "right scores".

Now work with these 2 arrays. Pick one from each array with highest sum, where first pick must be on the left

Here's how to solve this sub-problem:

build a 'max since first' shadow array based on the left-scores.
build a 'max since last' shadow array based on the right-scores.
pairwise add up these two arrays. Find the max in the final shadow array.
====Q: max distance: Given an array A of integers, find the maximum of j - i, subjected to the constraint of A[i] <= A[j].
Practical scenario -- given a pricing time series, find the "best" buy-sell trade with longest hold, because you want to have some exposure for as long as possible, perhaps as a hedge or for compliance (frequent-trading is penalized). Some hedge funds and IPO placement have lock-in periods.
Example: Input A: [3, 5, 4, 2]. Output: 2 for the pair (3, 4)

Sugg{ moving and expanding window?
Sugg: How about line sweep (Rahul's solution..)?

build a RbTree ordered by price-then-timestamp. The tree will have exactly N tree nodes even though prices are non-unique. In each tree node implicit payload is "my timestamp".

--O(N) solution using two shadow arrays
min-from-earliest
max-from-latest

two curves. As we sweep a horizontal line up, just keep track of the 2 intersections. I think the longest distance btw is the answer.

--Jargon -- 
Better prices are to the right on the treemap; (Can draw the price chart downward)
Earlier timestamps are invisible on the treemap;
up-the-tree is not visible on the chart and not important

--idea 1 Single fwd scan
invariant -- at any moment during the fwd scan, each tree node records "earliest price point that's same or worse than me".

Initial payload at each tree node -- next-better tree-node

After inserting a node on the tree, i look for the "neighbor" tree node defined as a node of same-price (pick earliest) or next-better-price (pick earliest). 
If neighbor has a payload, duplicate that payload.
After updating the payload, compute the "hold" time -- from the payload value (an earlier timestamp) to my timestamp. if this new hold time is longer than a global "longest hold", then update the global variable.

Trivial scenario -- If the neighbor doesn't exist, then the payload is my own timestamp
