[c=classic]
[e=ez]
[cc=careercup]
[L=leetcode]
[o=original, not discussed widely]
[v=easy to verify]

====[cc] Q (looks like contrived but very popular): You have k uneven lists of sorted integers. Find the smallest range that includes at least one number from each of the k lists. 

For example, 
List 1: [4, 10, 15, 24, 26] 
List 2: [0, 9, 12, 20] 
List 3: [5, 18, 22, 30] 

The smallest range here would be [20, 24] as it contains 24 from list 1, 20 from list 2, and 22 from list 3
-- moving window algo: first merge-sort all K clubs' items and remember the original clubId of each item. We end up with 
[0/2nd 4/1st 5/3rd 9/2nd 10/1st ...]

A 'basic window' is any subarray having representatives from each club.
A 'tight window' is a basic window that can't shrink further, i.e. the 1st and last items are the only reps of their clubs.

Now build initial window findNextWin(). Simple procedure -- 

When we build the window, we keep a data structure like {club1: position 1,3,6; club2: position 0,5; club3: position 2,4,..} Basically an array of vectors (probably slists). We update this table whenever we increment the front pointer in search of the next basic window. When we find a basic window, this table should have all K vectors non-empty and at least one of them singular.

now shrink this window shrink(). Here's one shrink algo:
for each vector, find the last added i.e. right-most position. Now suppose we are done. now out of these K positions, find the minimum i.e. right-most ... the left edge of our new tight window. If we can truncate this window at this position, then we keep shrinking

Another shrink algo:
For the current window, look at the clubId of the left edge (back ptr). 
Use the clubId to look in the table to get the slist. 
Head item in the sliist should be the index of back ptr. 
Pop this item and increment the back ptr. 
Repeat until the target slist has only one item. Now we have a tight window

Once we have a new tight window, we remember its size (... and compare it with the current winner...). After shrink(), we call findNextWin()

Suppose the left-most item is a clubX item. 
Now we move back ptr (clubX slist is now empty). 
Now we move front pointer i.e. right edge of the window, looking for the next clubX item. 
During this search, we update the table. 

* findNextWin() is O(1) per front ptr increment. Only touches the tail of slists
* shrink() is O(1) per back ptr increment. Only touches the head of slists

PriorityQ can speed up some, but won't improve bigO

====[cc] Q: Given an array of signed integers. Find two disjoint contiguous sub-arrays such that the absolute difference between the sum of two sub-array is maximum. 
* The sub-arrays should not overlap. 

eg: [2 -1 -2 1 -4 2 8] ans: (-1 -2 1 -4) (2 8), diff = 16 

O(n^2) algorithm was not accepted.
----
int-array problems are my relative weakness but I have done quite a few. I feel this is more about the algo rather the implementation

====[o]Q: maximize sum+dist. Given an array of signed ints. The score of any pair is their sum + their distance(i.e. subscript diff). Find the best pair.
I will call the best pair "left winner" and "right winner"

----
I don't know where this problem comes from. Don't know where to search for solution..Good.. but then i found https://stackoverflow.com/questions/32067492/maximize-sum-distance-for-integer-array is the same problem.

int-array problem is my relative weakness. O(NN) is simple but I think we can achieve O(N) with multiple scans.

How about two-pointers moving in?
How about two-pointers moving forward?

99 88 3 2 3 5 7 5 9< 4 2
88 99 2 3 5 1 6 3 6 0 1 2 3 
3 2 1 5 3 2 9 3 1 0 2 6 3 2
1 0 2 8 6 3 1 7 5 1 4

What if the first elements are 11,12,13,14? They are equally good as the left winner or they all lose to another item on the right
====Q: max distance: Given an array A of integers, find the maximum of j - i subjected to the constraint of A[i] <= A[j].
Example:
Input A: [3, 5, 4, 2]
Output: 2 for the pair (3, 4)

Another int-array problem -- my weakness. O(NN) is trivial. Can you beat that?
====topo sort: given a directed graph, any linear algo to assign ranks?
I prefer to use one rank for multiple nodes that can be simultaneously started/concretized/evaluated. This feature can increase flexibility and parallelism

rank table -- We can use a hashtable (or pre-sized vector) to store the ranks: {rank -> list of nodes of that rank}. Assigning a node means adding the node id to the correct list, in O(1)

Assumption 1: the original graph nodes contain precedents but no dependents. spreadsheet-model. I think this is Kahn's assumption.

Assumption 2: the original graph nodes contain dependents but no precedents. notification list or "call list", or "listener list"

In most situations, One of these two assumptions would hold, but rarely both.

Scan-1 O(V+E) -- build a hashtable-based two-way edgeSet representation of the graph. For each node, we maintain a hashset (or slist) of precedents and a hashset of dependents. The duplication is needed, as described below in the Kahn context. 

Scan-2 O(V) -- assign rank 0 to all top-level nodes (no precedent). Now we can use the rank table to scan rank-0 nodes

Scan-3 -- Now scan the last assigned rank, rank-0 in this case. 
For each node in that list, check each downstream child. 
Unconditionally remove (O(1) thanks to hashset) the precedent from inside the child. 
After that, If the child has empty hashset of precedents it is assigned rank 1. 
I now believe the precedent/dependent link is never accessed again, so we can remove both.

Repeat the last scan at Rank 1, then Rank 2..

Every node is assigned only once. Every edge is checked only once or twice.

Can the precedents hashset become an integer count?

-- simplicity
In this design, I use multiple Simple passes and avoid doing too much in one pass. If needed, you can combine Scan-2 and Scan-1.

We treat the original nodes as readonly -- nice simplification.
--terminology: 
precedent/dependent is accurate but abstract.
"Dependency" is a confusing term. It means someone I depend on. Better avoid this word in graph problems.
uplink/downlink is visual only in a tree with root on top

--Kahn uses "incoming edge" to mean a precedent
"All nodes with no incoming edge" ... implies a node object has this->precedents field

When he visits downstream nodes from "current node", he needs this->dependents field

This crucial detail is not explained in wikipedia
====Q[c e v] implement half-written abbr_iterative.h based on the abbr_ascendRecursive.h
Not so easy when the word contains dupe letters. I think hashtable is simplest solution in a realistic context, as explained in cookbook.py
