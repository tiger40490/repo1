====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

I think we should read some hints.

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!
====Q[L312] 0%: Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array "nums". You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
int-array optimization problem.
Looks more like math problem than algorithm problem.
Might be related to some classic problem.

array2 -- obvious decision
array3 -- With trough then I can prove we should always burst the trough
if ascending like illustrated, then I can prove the Explanation is aways optimal
if peak? Depends on the left/right. if lr > l+r+1 then should burst the peak. 

Looks like a DP idea.. any optimal substructure?

if there are 2 troughs near the ends, which one to burst or both independently?

--sol1 brute force
I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. 2^N nodes. Recombinant tree. From start to any given node, there are many distinct paths with a vaulue on each edge. 

Level n:   1 node
Level n-1: n nodes
Level n-2: nc2 nodes
      ...
Level 2:   nc2 nodes
Level 1:   n nodes
Level 0:   1 node

Each node at level K has K child or downstream nodes. This graph now suggests the shortest-path algo, but it might be the only way to solve the problem, like the bbg odometer.

But Level 2 has too many (N-choose-2) nodes. We need to prune the tree, from either start or end