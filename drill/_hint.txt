====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

I think we should read some hints.

idea 5: 95th percentile problem from NYSE
idea 4: multiple scans
idea 3: segments

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!
====Q[L312]: 0%: not really classic : Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array "nums". You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

If you burst a leftmost balloon, you collect 1*it*rightNeighbor coins. In other words, when multiplying 3 numbers, any absentee is a one.

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
int-array optimization problem.

Might be related to some classic problem.

Let's define a generic math-function of 3 balloon IDs score(myle, me, myri). In this problem, score() is simply "return myle*me*myri ", but in the next problem, score() could be any math function of the three inputs. 

--solution1 DP 
I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. Exactly 2^N nodes in the Recombinant tree, i.e. 2^N possible snapshots i.e. 2^N combinations of these N balloons. 

Every edge has a score. To compute the score, we only need the two nodes of the edge to deduce the 3 balloons for score(). Therefore, we can work out a score upward or downward the graph. 

Pyramid -- Let's assume at bottom is "origin" i.e. snapshot of the original array ..Level 500; on top is "phi" i.e. snapshot of the empty array .. Level 0. 

From origin to any given node, there are many distinct paths each with a total score up to that node. If a node has 55 paths to it, the max sum among the 55 paths would be the uprank (upward rank) of the node. 

If the node also has 44 paths from phi, the max sum among the 44 paths would be the downrank (downwrd rank) of the node.

To our delight, uprank of a node AA at Level-5 depends only on the six Level-6 parent node upranks, so we don't need to remember all the distinct paths to AA:) Space complexity is up to O(max size of a level). Time complexity is O(V+E) i.e. visit every edge.

* I hope to update upranks from bottom up, since there are rather few nodes at bottom.
* I hope to update downranks from top down, since there are rather few nodes at top.
* If Level K has more nodes than Level K-1, then we don't want to compute upranks from K to K-1. Instead, we can more efficiently compute downranks from K-1 to K.

Suppose i have computed all downranks down to Level 7 nodes .. 77 nodes
Suppose i have computed all upranks up to Level 8 nodes .. 88 nodes
I think we can now compare all the 77*88 paths between Level 7 and 8. Between Node 7A and 8B, the path sum is 

  uprank_8B + edge score + downrank_7A

Level n:   1 node
Level n-1: n nodes
Level n-2: nc2 nodes
      ...
Level 2:   nc2 nodes
Level 1:   n nodes
Level 0:   1 node

Each node at level K has K child nodes above. This graph now suggests the max-path-sum algo, but it might be the only way to solve the problem, like the bbg odometer.

consider a DP algo to update the score at each node at level K, ie the max sum from root till here, via one of the K-1 nodes at level K-1 

But Level 2 has too many (N-choose-2) nodes. Can We prune the tree, from either origin or phi?