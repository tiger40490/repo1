====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

I think we should read some hints.

idea 5: 95th percentile problem from NYSE
idea 4: multiple scans
idea 3: segments

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!
====Q[L312]: 0%: no classic : Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array "nums". You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

Not so common, so let's not spend too much time

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
int-array optimization problem.

Might be related to some classic problem.

Let's define a function score(myle, me, myri). In this case, score() is simpley the myle*me*myri, but in the next problem, score() could be any math function of the three inputs.

array2 -- obvious decision
array3 -- With trough then I can prove we should always burst the trough
if ascending like illustrated, then I can prove the Explanation is aways optimal
if peak? Depends on the left/right. if lr > l+r+1 then should burst the peak. 

Looks like a DP idea.. any optimal substructure?

if there are 2 troughs near the ends, which one to burst or both independently?

--sol1 DP 
I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. 2^N nodes in the Recombinant tree. Each edge has a score. From start to any given node, there are many distinct paths each with a total score up to that node. If a node has 55 paths to it, the max sum among the 55 paths would be the rank of the node.

To our delight, rank of a node AA at Level 5 depends only on the 4 parent node ranks, so we don't need to remember all the distinct paths to AA:) Space complexity is up to O(max size of a level). Time compelxity is O(??) i.e. visit every node

Level n:   1 node
Level n-1: n nodes
Level n-2: nc2 nodes
      ...
Level 2:   nc2 nodes
Level 1:   n nodes
Level 0:   1 node

Each node at level K has K child or downstream nodes. This graph now suggests the max-path-sum algo, but it might be the only way to solve the problem, like the bbg odometer.

consider a DP algo to update the score at each node at level K, ie the max sum from root till here, via one of the K-1 nodes at level K-1 

But Level 2 has too many (N-choose-2) nodes. We need to prune the tree, from either start or end