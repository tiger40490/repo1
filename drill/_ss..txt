1) i may want to spend some time improving/documenting the complete java solution. 
2) implement the same idea in c+++. tbudget = 10H
3) if have time implement BFT

Keep count of the total number of cells and also running total of concrete cells. Once they tally, game over.

Q3: What if they never tally? 

--global containers:
p2d: rcid -> linked list of downstream nodes
--node class
original formula. 
set of unconcretized upstreams (uu). We would progressively remove from this set during 2nd pass. Once it becomes empty, we would concretize the formula.

--basic algo
In first pass, collect all top-level nodes.
In 2nd pass, take each top-level node and concretize as many downstream nodes as possible
first pass also builds the graph by populating p2d + the links in each upstream node

A3: after iterating all top-level nodes, if no tally, then cycle exists

Can we prove this algo would do the job on a cycle-free sheet?

space complexity is just the hashable + some list of top-level nodes + graph

time complexity? O(V+E) since in 2nd pass, each edge is visited at most twice --
* downstream tracing
* referencing upward node (one level up exactly), while evaluating a formula 

--details of 2ndd pass:
BFT is better. Simply enqueue all top-level nodes at start.

When we follow the down link to visit a node Tom, we always remove at least one item from Tom's uu. If empty, then concretize Tom and descend

--I prefer c++
* single-file solution
* TMP practice and showcase
* less benchmarking
* my c++ needs more practice, a lot more than java
