Don't over-invest
* G100 but not a classic 

To handle sparse sheets with most rows and columns empty, i will use a hash table keyed by rcid (RowColIdentifier). This can reduce memory footprint by 99% and consequently reduce paging and increase cache efficiency.

Don't full-scan the hash table.

Keep count of the total number of cells and also running total of concrete cells. Once they tally, game over.

Q3: What if they never tally? 

--node class
linked list of downstream nodes
original formula. 
linked list of unconcretized upstreams (uu list). We would progressively remove from this list during 2nd pass. Once it becomes empty, we would concretize the formula.

--basic algo
In first pass, collect all top-level nodes.
In 2nd pass, take each top-level node and concretize as many downstream nodes as possible
first pass also builds the graph by populating the links in each upstream node

A3: after iterating all top-level nodes, if no tally, then cycle exists

Can we prove this algo would do the job on a cycle-free sheet?

space complexity is just the hashable + some list of top-level nodes + graph

time complexity? O(V+E) since in 2nd pass, each edge is visited at most twice --
* downstream tracing
* referencing upward node (one level up exactly), while evaluating a formula 

--details of 2ndd pass:
BFT is better. Simply enqueue all top-level nodes at start.

When we follow the down link to visit a node Tom, we always remove at least one item from Tom's uu list. If empty, then concretize Tom and descend

--I prefer c++
* single-file solution
* TMP practice and showcase
* less benchmarking
* my c++ needs more practice, a lot more than java
