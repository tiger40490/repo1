====Q [c DP] from Rahul
Given longer and short strings Haystack vs Needle, can string-N match a sub-sequence (not necessarily substring) of string-H? You can say we are checking if string-N is hiding in string-H. If yes how many hiding places or sub-sequences can you find? 

More formally, if length of string-N is 5, then each hiding place is a tuple of 5 subscripts into string-H...

Eg: H = GeeksForGeeks; N = Gks. Answer is 4 subsequences

My idea is backtracking recursion with memoization, hopefully O(len(H) * len(N))

I feel bottom-up is more efficient (avoids deep stack) but I only know a top-down algo

H and N are treated as immutable reference data.

f(n,h) shall return a count of hiding places where N[0 to n] hides in H[0 to h]

We build the memorization for f(n,h) from small to big, when we come to f(n=2,h=12), we already have the lower results.

N=Gks H=GeeksForGeeks
  012   0123456789012

f(2,11) results (1 in this example) are part of my results
In this case, N[n)==H(h), so we also need f(1,11) -> 3 matches.

Now suppose H gets an additional 'x' and we want f(2,13)? Since N(n)!=H(h), we only want f(n, h-1)

--the bottom up algo:
f(n,h) only needs f(n-1,h-1) and f(n,h-1)
if n > h, return 0
if n==0, i can find the return value easily
if n==1, f(n,h-1) + ( N[n]==H[h]? f(n-1,h-1):0)
====Q: insertion sort quick-n-dirty but correct
====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

--O(1) space solution
Get a quick estimate of the median. 
Then move two pointers from far ends towards center.
Whenever med < left item,  freeze left ptr.
Whenever right item < med, freeze right ptr.
when both pointers stoped, swap them, then unfreeze both.

Now list is partitioned into two halves. Now divide and conquer. Total logN scans.

--O[N] space (not O[1]) idea
merge sort using an aux array of same size
1) divide the array into 2^j segments each up to 2 elements, rembering the (segment) boundaries.
2) sort each segment
3) merge first 2 segments and output to a new array of N but only use the first few slots
4) similarly , merge 3rd and 4th segments into the new array, using the next few slots
Once we merge all pairs, entire new array is populated and old array can be reset to 0 and usable as a blank array
Now the segment boundaries are updated and reduced by half. When segment count becomes 2, we would be on the last merge.
5) repeat Step 3

In total we visit each of N nodes logN times

====Q[Lv] 60%: Given array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

well-defined problem:)
greedy?
O(1) space probably means swapping
mutable?
-- with more space, I can use a hashtable to achieve O(N)
-- My O(N) algo {applicable for any-size integers and also other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

====Q[c !e L !v] 50%: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. No dot !
I think we can modify the existing solution. No need for an optimal solution

=====Q[L] 60%: Given an array nums of K integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(KK)
%%A: separate into (M) non-negatives and (N) negatives. M+N=K. get (NN) pairs among negatives .... and look up the sum in a pre-populated hash table of M items.
O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode? No obligation

====Q[c e v] implemet half-written abbr_iterative.h based on the abbr_ascendRecursive.h
Not so easy when the word is not sorted and container dupe letters. I think hashtable is needed

====Q[Lv] 80%: classic generator algo: Leetcode problem 17... Given a string containing digits from 2-9 inclusive, return all possible letter combinations (not permutations) that the number could represent.

2: abc
3: def
4: ghi
5: jkl
6: mno
7: pqrs
8: tuv
9: wxyz

Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 

--we need good variable names. 
For the 9 digits, every digit is immediately mapped to a name string like '2' -> "er" and I hope not to use the digits any more.
Java would use enum

To minimize confusion, Create typedef LOB as alias for either vector<char> or the string form. Will have 8 const LOB instances. Java would use enum

struct Bundle{
  set<vector<char>> clubOfWords; 
  size_t repeatOfThisButton;
  LOB lob; //compile-time constant
};
--
The utility function would be
Bundle gen(vector<char> const & lob /*lettersOnOneButton*/ , int repeat). This function is fairly simple. for er_5, we have 3^5 possible words in the club

sort input into 222223444 then create map: 
"er_5" -> a bundle
"san1" -> a bundle
"si_3" -> a bundle

A major Miletone is when the map is populated with the clubs. Now generate combos ... better use "append" approach.
