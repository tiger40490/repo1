====for a binTree, print subtree size/height at every node
====practice in-order-walk iterative/recursive
====comboSum.cpp has a half-written memoization version, based on a recursive top-down, but not necessarily appropriate or easy to remember/reproduce
====[o]Q: maximize sum+dist. Given an array of signed ints. The score of any pair is their sum + their distance(i.e. subscript diff). Find the best pair.
I will call the best pair "left winner" and "right winner"

----
I don't know where this problem comes from. Don't know where to search for solution..Good.. but then i found https://stackoverflow.com/questions/32067492/maximize-sum-distance-for-integer-array is the same problem.

int-array problem is my relative weakness. O(NN) is simple but I think we can achieve O(N) with multiple scans.
--my solution
scan forward to build a shadow array of "left scores" for each element s[i]:= a[i] - i. If a[i] Value were to increase by 1, the score would also improve by 1...

Scan backward to build a shadow array of "right scores" r[j]:= a[j] +j

Now work with these 2 arrays. From each array, Pick one to form a best pair with highest sum, where first pick must be on the left

Here's how to solve this sub-problem:

build a 'max since first' shadow array based on the left-scores.
build a 'max since last' shadow array based on the right-scores, but Kyle pointed out this is not needed. We may want to test both
pairwise add up these two arrays. Find the max in the final shadow array.

