====[cc] Q: Given an array of N signed integers. Find two disjoint contiguous sub-arrays such that the absolute difference between the two sub-array sums is maximized. 
* The sub-arrays should not overlap. 

eg: [2 -1 -2 1 -4 2 8] ans: (-1 -2 1 -4) (2 8), diff = 16 

O(n^2) algorithm was not accepted. 

Without loss of generality, let's assume the best result includes a min subarray on the left and a max subarray on the right.


--idea 1: a partition point at 5 splits the array to 0-4 and 5-end
For a given partition point, we can find the min subarray on the left and also max subarray on the right.

A O(N^2) solution can be designed based on this idea -- at each partition point, O(N) search of min subarray sum on the left and max subarray sum on the right 

---idea 2: 2 colliding pointers le and ri. 
0-le contains a min subarray, and ri-end contains a max subarray. 

How do I move the 2 pointers?

if le item is positive then we should grow the max subarray.
--- idea 3: O(N) scan fwd to record at each position "max sum ending here" and "min sum ending here". Ditto reverse scan. 

The subarray is never empty, as in my minSubarraySum.py.

End up with N-array of {a,b,c,d} Records. Then scan this array in O(N)
----
int-array problems are my relative weakness but I have done quite a few. I feel this is more about the algo rather the implementation

====[cc] 60% Q (looks like contrived but very popular): You have k uneven lists of sorted integers. Find the smallest range that includes at least one number from each of the k lists. 

For example, 
List 1: [4, 10, 15, 24, 26] 
List 2: [0, 9, 12, 20] 
List 3: [5, 18, 22, 30] 

The smallest range here would be [20, 24] as it contains 24 from list 1, 20 from list 2, and 22 from list 3
-- moving window algo: first merge-sort all K clubs' items and remember the original clubId of each item. We end up with 
[0/2nd 4/1st 5/3rd 9/2nd 10/1st ...]

A 'basic window' is any subarray having representatives from each club.
A 'tight window' is a basic window that can't shrink further, i.e. the 1st and last items are the only reps of their clubs.

Now build initial window findNextWin(). Simple procedure -- 
When we build the window, we keep a table like {club1: position 1,3,6; club2: position 0,5; club3: position 2,4,..} Basically an array of vectors (more likely slists). We update this table each time we increment the front pointer in search of the next basic window. When we find a basic window, this table should have all K vectors non-empty and at least one of them singular, including the last updated vector.

now shrink this window via shrink(). Here's one shrink algo:
for each vector, find the last added i.e. right-most position. Now suppose we are done. now out of these K positions, find the minimum i.e. right-most ... the left edge of our new tight window. If we can truncate this window at this position, then we keep shrinking

Another shrink algo:
For the current window, look at the clubId of the left edge (back ptr). 
Use the clubId to locate an slist in the table. Head item in the slist should be the index of back ptr. 
if not empty, Pop from slist and increment the back ptr; else exit shrink() 
Now we have a tight window.

Once we have a new tight window, we remember its size (... and compare it with the current winner...). After shrink(), we call findNextWin()

Suppose the left-most item is a clubX item. 
Now we move back ptr (clubX slist is now empty). 
Now we move front pointer i.e. right edge of the window, looking for the next clubX item. 
During this search, we update the table. 

* findNextWin() is O(1) per front ptr increment. Only touches the tail of slists
* shrink() is O(1) per back ptr increment. Only touches the head of slists

PriorityQ can speed up some, but won't improve bigO

====memo(fn, *params) should be extracted as a generic utility

====generic_factorize.py to use yield
====comboSum.cpp has a half-written memoization version, based on a recursive top-down, but not necessarily appropriate or easy to remember/reproduce
====Q: a slist has one more link field in each node. It's the address of a random node in the same slist. How do you serialize this linked list?

I think the generic solution works but there is hopefully a more intuitive one -- assign id to each new node in the first scan. 

first scan to traverse slist and visit all nodes. 

writing to file is only in 2nd scan:

2nd scan visits each node to save the random field along with the host node id

I feel the challenge is ECT and this problem may show up.
====Q: insertion sort quick-n-dirty but correct
====Q[Lv] 60%: Given array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

well-defined problem:)
greedy?
O(1) space probably means swapping
mutable?
-- with more space, I can use a hashtable to achieve O(N)
-- My O(N) algo {applicable for any-size integers and also other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

====Q[c !e L !v] 50%: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. No dot !
I think we can modify the existing solution. No need for an optimal solution

=====Q[L] 60%: Given an array nums of K integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(KK)
%%A: separate into (M) non-negatives and (N) negatives. M+N=K. get (NN) pairs among negatives .... and look up the sum in a pre-populated hash table of M items.
O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode? No obligation
====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

--O(1) space solution
Get a quick estimate of the median. 
Then move two pointers from far ends towards center.
Whenever med < left item,  freeze left ptr.
Whenever right item < med, freeze right ptr.
when both pointers stoped, swap them, then unfreeze both.

Now list is partitioned into two halves. Now divide and conquer. Total logN scans.

--O[N] space (not O[1]) idea
merge sort using an aux array of same size
1) divide the array into 2^j segments each up to 2 elements, rembering the (segment) boundaries.
2) sort each segment
3) merge first 2 segments and output to a new array of N but only use the first few slots
4) similarly , merge 3rd and 4th segments into the new array, using the next few slots
Once we merge all pairs, entire new array is populated and old array can be reset to 0 and usable as a blank array
Now the segment boundaries are updated and reduced by half. When segment count becomes 2, we would be on the last merge.
5) repeat Step 3

In total we visit each of N nodes logN times
