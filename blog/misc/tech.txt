==new blogpost ##coreJava QQ topics: stand-out from crowd
beware of othRisk
* low-level core threading features -- higher market value than ecosystem features like concurrency utilities
* jGC
* latency tuning -- including JIT
* collections internals
-- second tier QQ topics
* reflection, AOP, bytecode engineering? never popular
* advanced generics? out of fashion
-- other advanced QQ topics
* class loader internals? out of fashion
* JNI? never popular
* jvm internals? never popular and never needed on any project
==
--update blogpost on word ladder
first scan ... No need to be extra clever as this simple O(NN) algo is optimal IMO. No need to worry about the visualization of the graph either because the edge list is a proven representation

"seen" -- or array of size N. Array is more elegant than hash table in this case.

the last routine can be extracted to a "simple routine to be implemented later", so no need to worry about it in a white board session.

--new blogpost: assignment^rebind across languages 
for a non-primitive variable, java assignment is always rebinding. Java behavior is well-understood and simple, compared to python.

Compared to python, c++ assignment is actually well-documented .. comparable to a mutator method.

python assignment is always rebinding afaik, even for an integer. Integer objects are immutable, reference counted.
In python, if you want two functions to share a single mutable integer variable, you can declare a global int. 
It would be in the global idic/namespace. q[=] has special meaning..

Alternatively, you can wrap the int in a single-element list and call list mutator methods, without q[=].

See my experiment in github py/88lang

--no blogpost
adding "const" can lead to bewildering template errors that don't show any relation to const

--no blogpost
# You can put python function body and header on same line :)
def packed(haystack):  return ''.join(haystack.split())
