--fuxi: hasSameContent(dict1, dict2): return dict1 == dict2 
--new  : linkedHashSet as dynamic sorted collection with O(1) remove but without insert. 

Not available in other languages.

Q: is deletion really constant time? I think so. Hashtable delete then linked-list delete

--new: java ref closest cousin]]c++: pointer!!ref
java (and c#) reference varialbes are more like pointer variables than c++ reference variables
c++ reference variables can't be reseated. This is the major difference.

--why can't we take the address of a c++ reference variable? 
A pointer is conceptually a runtime object, occupying run time memory, with an address.

A ref is strictly a variable and never a runtime object, so it has no address at runtime. I suspect compiler replaces it with the target variable.

--new: competitors to x86 instruction sets
Interviewers often focus on x86 instruction sets, but I could point out competing instruction sets.

IBM's PowerPC and Oracle's Sparc, were once popular instruction sets in HighPerformanceComputing. Even if they are less popular now, the still have a presence.

AMD64 instruction set (i.e. x86-64) was created at AMD, as an extension on x86

IA-64 instruction set was created at HP then Intel, widely deployed in data centers.

If interivew is not 100% focused on server-side, then I would point out ARM instruction set is dominant in handheld.

--update blogpost on Optional.java
https://dzone.com/articles/considerations-when-returning-java-8s-optional-from-a-method shows the pitfalls of returning Optional from a method.

I feel this is like borrowing from a loan shark to avoid accidental credit card interest charge. 

If you are careful, it can help you avoid the NPE of the traditional practice, but if you are undisciplined (like most of us), then this new stragey is even worse -- 

Traditional return type is something like String, but caller has to deal with nulls. New strategy is supposed to remove the risk/doubt of a null return value, but alas, caller still needs to check null first, before checking against empty!

--new:
For c++ to hold its ground in the latency benchmarks
* no new no malloc. Use stack and data segment
* no STL no std::string no shared_ptr
* optimize d-cache and i-cache
* use compile-time programming

For java, 
* no GC

--new or update blogpost: advantage of make_shared
* one allocation fewer. I think one allocation is thousands of times slower than a simple calc
* code size is smaller and more i-cache friendly


--really low-latency apps should probably avoid lock-free... Strictly single-threaded mode, strictly. 

--fuxi: mlphone bb app settings
in any bb app, hit the bb icon at bottom right -> hit gear icon on bottom left -> per-app settings

--fuxi: cpu set seems to be a linux kernel feature, not just a container feature

--new: cpu affinity
sched_setaffinity is a syscall probably close to the hardware. 
all other *affinity* functions are based thereon

*_np in function name means non-portable

is there a cpu instruction for affinity?

Need to read more. Similar to socket QQ -- Not deep, but even more academic than socket

--new:
is malloc a kernel service, syscall or a userland function offered in a regular library?

Can I implement my own DAM without involving the kernel? I would say some kernel sys call is needed.

Is there a cpu instruction for DAM? Does cpu care about heap vs stack?

--fuxi: Martin's low-latency java talk
java has no deallocation cost. C++ deallocation is worse than allocation. Deallocation may use locking if performed across threads.

My Questions
Q: for low latency should we avoid concurrency ?
A: yes
%%A: parallel processing in ST-Mode is good but avoid any form of synchronization 

Q: If I don’t use heap, and only use stack and static memory….?
A: heap allows sharing between threads

Q: why is JIT not available to c++?
%%A: c was not designed for JIT and ineffective 

--pointer as a field of a class is uninitialized by default
I think Ashish's test shows it

However, such a field creates an opportunity for mv-ctor. The referent object is usually on heap on in static memory

class-type fields like a field of Integer type is always initialized via the ctor. Remember the BCCD sequence.