--new blogpost: RDBMS ...
stored proc can greatly simplify business logic...
Even without stored proc, a big join can replace tons of application code implementing non-trivial business logic
hashtable lookup can be implemented in SQL (join or sub-query) with better clarity and instrumentation
No implicit complexities in initialization, concurrency, input validation, null ptr handling, state validity, invariants, immutabilities, ... Design patterns are often employed to deal with many of these complexities, but SQL can sidestep these complexities.

Modularity is another advantage. The query logic can be complex and maintained as an independent module (On the presentation layer, javascript offers  modularity too). Whatever module dependant on the query logic has an dependency interface that's well-defined and easy to test, easy to investigate.

I think one inflexibility is adding new column. There are probably some work-arounds but noSQL is more flexible.

--new new new blogpost: java perf^simplicity
Paradoxically
java's syntax simplicity is on par with python, better than c# and much better than c++.
java's performance is on par with c# and c++, largely due to JVM and JIT

java has been popular on web servers, and crucially the newer mobile, cloud, big-data platforms, beating c++, c#, python

java's adoption rate as a foundation platform or integration-target... is better than other languages. Many products are built for java, on java or with java in mind. I'm deliberately vague here because I don't want to spend too much time analyzing this vague, general observation.

--new blogpost 1^2-pass algos
90% of the time 2-pass algo is simpler conceptually.

However, in my 2-pivot partition algo, a single-pass algo is simpler.
