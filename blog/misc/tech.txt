--new: create more effective singletons
In numerous legacy java codebases I worked with, many important methods are non-static methods but their usage suggest they should have been designed as static methods.

This complicates refactoring and testing. 

Static methods can be used without (somehow) getting a handle on a host object. Note “getting” can be very complicated.

Solution – create singletons (not strict as in the java sense) in those host classes.
--new: 
In the json loader project, when I refactored an overgrown method, I often extracted part of it into a “delegate” method or a helper method.

This delegate method is invoked only from the original method. It can have the same method name, same signatures, sometimes in the same or another file.

The identical name between both methods is a tell-tale sign of their relationship.

If the original method thus becomes very simple, then we refer to it as a wrapper. 

A more common extraction procedure creates a reusable routine that’s invoked from multiple places -- DRY
--
Impact cache updates -- can use IP multicast?

--update blogpost on clone()
clone() is needed for immutable design, a hot topic for core java IV. 
However, clone() is not well known or well quizzed

clone() is far more obscure than c++ copy ctor

ImmutableComposite can have field objects that are mutable types iFF they are clonable.

--fuxi:
Citrix became very slow when I moved to a location far from the wifi hotspot. I could see the signal strength dropping very low.

--fuxi: JVM remote debugging is not so foolproof.
GDB is not so foolproof. See my blogposts.

We need to fully embrace the reality that live debugging is often impractical.

In contrast, "echo" is the gold standard in code tracing.

--fuxi: 5GHz ^ 2.4GHz wifi
Range favors lower frequency. Bigger homes may need it.

bandwidth favors higher frequency. Video streaming.

Overcrowding in 2.4 can cause intermittent connectivity issues, but is it 5% of the time or 0.05% of the time? Not sure. Microwave did hit me.

-- clone() is needed mostly in one context -- immutable composite class
This topic is relevant in QQ IV.

If you design a composite class (ImmComp) to be immutable, where some field is of type CC, then you need to clone each CC object received or returned from ImmComp. Remember the 2010 Citi muni interview.

Aha -- if ImmComp can be refactored to hold primitve/string fields of CC rather than a CC field, then things are simpler. CC needs no clone() 
Aha -- if CC is already an immutable class then things are simpler. We probably don't need clone()

Warning: CC could be the root of an object graph such as a tree. When we clone CC and CC contains a field of type DD, then a mutable DD would be part of CC's object state, and also ImmComp's object state. Any change to DD would break immutability of ImmComp :(

-- new: stop/suspend/resume/destroy in java
Occassional IV question

These four methods are still part of the API and stop/suspend/resume are implemented and available. (destroy() is never implemented.) They are all unsafe most for two reasons

1) suspend() forces the thread to suspend without releasing locks if any. Susceptible to deadlock. The resume() method is used with suspend().
2) stop() forces the thread to die and release all locks. No deadlock risk AFAIK, but if the thread was forced to release a lock, then the lock is likely needed to protect some object state (such as fund transfer). Force-Release of the lock would expose those object's invalidate state.

-- to start excel with a spreadsheet file, i can run this command from git-bash:

$ start excel assets\{git.xls

--fuxi: hasSameContent(dict1, dict2): return dict1 == dict2 

--new : linkedHashSet as dynamic sorted collection with O(1) remove/lookup, but insert is O(logN)
Not available in other languages.

one-time sort in a temporary array, then one-time build the linkedHashSet. Additional insert is O(logN). Additional lookup/remove is O(1)

--why can't we take the address of a c++ reference variable? 
A pointer is conceptually a runtime object, occupying run time memory, with an address.

A ref is strictly a symbol and never a runtime object, so it has no address at runtime. I suspect compiler replaces it with the referent variable.

such a reference is like a syntactical sugar, mostly for func params. Then came rvr !
--new:
For c++ to hold its ground in those simplistic, often numerical, latency benchmarks
* no new no malloc. Use stack and data segment
* no STL no std::string no shared_ptr
* optimize d-cache and i-cache
* use compile-time programming

For java, 
* no GC

--new or update:
really low-latency apps should probably avoid lock-free... Strictly single-threaded mode (no shared mutable), strictly. 
Lockfree programming assumes the presence of shared mutable. If no shared mutable, then these constructs would exert a unwanted performance penalty 

--fuxi: mlphone bb app settings
in any bb app, hit the bb icon at bottom right -> hit gear icon on bottom left -> per-app settings

--fuxi: cpu set seems to be a linux kernel feature, not just a container feature

--new: cpu affinity
sched_setaffinity is a syscall probably close to the hardware. 
all other *affinity* functions are based thereon

*_np in function name means non-portable

is there a cpu instruction for affinity?

Need to read more. Similar to socket QQ -- Not deep, but even more academic than socket

--new:
is malloc a kernel service, syscall or a userland function offered in a regular library?

Can I implement my own DAM without involving the kernel? I would say some kernel sys call is needed.

Is there a cpu instruction for DAM? Does cpu care about heap vs stack?

--fuxi: Martin's low-latency java talk
java has no deallocation cost. C++ deallocation is worse than allocation. Deallocation may use locking if performed across threads.

My Questions
Q: for low latency should we avoid concurrency ?
A: yes
%%A: parallel processing in ST-Mode is good but avoid any form of synchronization 

Q: If I don’t use heap, and only use stack and static memory….?
A: heap allows sharing between threads

Q: why is JIT not available to c++?
%%A: c was not designed for JIT and ineffective 

--pointer as a field of a class is uninitialized by default
I think Ashish's test shows it

However, such a field creates an opportunity for mv-ctor. The referent object is usually on heap on in static memory

class-type fields like a field of Integer type is always initialized via the ctor. Remember the BCCD sequence.
