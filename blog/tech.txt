-- update eviction.py
I should convert the dict back to array, and have a single continuous fwd scan, to replace the outer while loop

-- new: memory layout: vector{string}
observation: the vector's backing array can grow, so this array must be allocated via array-new[1], for a pre-computed capacity.

observation: the string's char-array can grow (unlike String.java), so this array must be allocated via array-new.

So the memory layout is similar to vector{vector} !

Let's assume a capacity of 90 in a 64-bit machine.

Does the vector hold pointers to string? No. An array of 90 pointers require 720 bytes, but an array of 90 strings take 32*90 bytes.

So the memory layout is an dynamic array of 90 "shells". Each shell holds a pointer to a char-array on heap.

[1] or malloc]

-- new: wrapper struct over container elements
Sometimes I need to construct a wrapper instance holding some kind of readonly reference to an element in a container.

Do you want to hold raw pointers to the element?
Do you want to hold smart pointer? No!
Do you want to hold subscript into the container?
Do you want to hold iterators into the container?

If subscript is stable, then I think it is the cleanest design. This would be the case for array-like containres without deletion or reallocation.

The problem with a pointer field is ... a can of worm. Whoever reading the code would brace themselves because a pointer field often entails ownership, clean-up, customized copy operation...

The iterator solution can be viable iFF the iterator is guaranteed stable. That depends on the iterator invalidation rules. See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=15251&action=edit

-- update blogpost on fine print
no-arg ctor call can be the entry point of 99% of the logic. It looks trivial

-- new: string pbref^pbclone
In java and c#, string objects are always passed by reference. 

An extreme example is useful like a huge string object with 999 trillion characters. In java and c# this object is passed around without cloning the content. A cloning process takes hours at least.

In C, a cStr is an array, either on heap or elsewhere. It is often passed by pointer (pbref). Pbclone is common when the length is small. In C, string length is usually known in advance. 

In C++, std::string is often pbclone but it can be pbref. Overall, Passing std::string is more complicated than the other languages. 

Inside many c/c++ structs I have seen, string fields are often represented as a fixed-length char-arrays without terminating null char. Note compilers require that length to be a compile-time constant, to support sizeof()

-- new
The propaganda, the simplistic view favors scale-out. 

scale out can underperform.
similarly, multithreaded qsort can be slower than single-threaded 

The paper on COST (Configuration that Outperforms a Single Thread) asserts that 
The unoptimized implementation "scales" far better, despite (or rather, because of) its inferior performance. 

The COST of a given platform for a given problem is the count of cpu cores required before the platform outperforms an optimized single-threaded implementation.

The COST can be hundreds of cores. A given scale-out platform may require that many cores to beat a single-threaded implmenetation. If you grow an army of shrimps against a whale in a tug-of-war, you need an army of millions.

-- BitMain
Can python make use of multiple cores? python multiprocessing?

Q: in your java project, is memory an issue?

You can read up Filecoin and IPFS

-- new: 
seg fault is an immediate response or async, based on signals?
Is core-dump performed by a signal handler?

I think my linux book has some details.

-- py multiprocessing
Py Multiprocessing is an alternative to STM parallelism. This is python's only way to make use of multiple cores.

Py doesn’t support Synchronized threading, due to GIL.

-- fuxi: multiprocessing.pm
This module supports spawning processes using an API similar to the threading module. The multiprocessing package effectively side-stepping the Global Interpreter Lock by using subprocesses instead of threads. Therefore, the multiprocessing module allows the programmer to leverage multiple processors on a given machine. 

-- new: c++ excp!=as useful as in newer languages
java errors are almost always wrapped in exceptions. 
C++ has a tradition of UDB and USB. low level errors are often left to the hardware or the OS. See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=954&action=edit
exceptions create programming pitfalls in dtor, swap etc
exception passing is trick and a major source of bug
exceptions affect efficiency and performance (the very j4 C/C++) and is often disabled in gcc, or avoided. Therefore, when it comes to exceptions, Ironically the most useful language feature is 'noexcept'.
Standard library uses very few exceptions.

.. C integration .. Many real world projects have substantial codebase in C, and often adopt C programming traditions.
C doesn't support exceptions. 
Exceptions are a high-level langage feature. 
Low-level langages like C use error code.

-- new: GPGPU: learning notes
A GPU is a programmable processor on which thousands of specialized cores (thread count is 10x higher) run simultaneously in massive parallelism. Although GPUs usually operate at much lower clock speeds than CPUs, a GPU has a massive amount of cores that help with multitasking.

Designed to work with programming languages such as C/C++, CUDA is an accessible platform, requiring no advanced skills.

CUDA accelerates many applications, including numerical analytics, scentific computing, and deep learning, encryption, . 

A "stream" is a set of records that require similar computation. Streams provide data parallelism. A "Kernel" is a function applied to each element in the stream. In the GPUs, vertices and fragments are the elements in streams and vertex and fragment shaders are the kernels to be run on them. 

Ideal GPGPU applications have large data sets, high parallelism, and minimal dependency between data elements.

GPU computing refers to Graphics Processing tasks, using graphics jargons; GPGPU refers to non-graphic computing.

Energy efficiency -- GPUs perform much more work for every unit of energy than CPUs. That makes them key to supercomputers that would otherwise push past the limits of today’s electrical grids.

x% of the blockchain mining computations can use gpgpu, but the other (100-x)% can only run on CPU.

-- new:
The words "digital currenc, virtual currency" can be unrelated to blockchain. For example, frequent flier miles, or ccard reward points can be transferred or traded. They can become virtual currencies.

-- new: unix domain sockets vs sockets to localhost

-- new or update blogpost on IPC
one process can send a signal to another process. This is a simple yet well-supported, proven IPC mechanism.

-- fuxi: uniqPtr MktVal imt sharedPtr
.. due to move-semantics, which is a hot favorite IV QQ topic

--fuxi
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency.
Low latency sockets don't rely on signals for immediate action

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!

--new: malloc != syscall
is malloc a kernel service, syscall or a userland function offered in a regular library?

Can I implement my own DAM without involving the kernel? I would say some kernel sys call is needed.

Is there a cpu instruction for heap allocation? Does cpu care about heap vs stack? Yes the CPU cares about the stack. There are dedicated stack-registers in the CPU
whilst the stack space is managed via the CPU, the heap is not managed automatically. The size of the heap can also be considerably larger than the stack and the allocation of memory must be performed manually within a program. Memory also has to be freed manually, again unlike the stack.

Can check my linux book or google on brk()

-- fuxi: set in python
set is the least used builtin container. I seldom use it, becasue dictionary is always richer.
( Similarly, list is always richer than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset
