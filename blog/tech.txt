
-- update https://btv-gz.dreamhosters.com/2021/01/29/ccomposite-arrays/
The pattern: RAII is meaningful only for a class with a custom dtor. The dtor should clean up some resources, usually via a resource handle implemented as a heap ptr. 

Consider a simple struct B with fields and a synthesized dtor.

Q1: Is there a meaningful RAII in a vector of B?
A: Yes vector's internal array is on heap. Destructing the vector would deallocate the array elements i.e. individual B instances. The B dtor is not really part of RAII.

Q2: Is ther a meaningful RAII in a vector of B pointers to heap?
A: memory leak ! the vector dtor would destruct each element, but the dtor for a ptr is noop, not operator-delete :( 
A: to prevent memory leak, you need vector of RAII smart pointers.

Q3: what if B has a pointer to some heapy thingy?
A: then B dtor should be customized for RAII. A1 / A2 still apply

-- new pre-sized std::vector
First we had fixed arrays. Then we had VLA. Then we had malloc arrays. I think fixed-sized std::vector is the upgrade from malloc array.

It offers RAII clean-up.

It offers copy and move support, so you can pass it into/out of function.

-- new: memory layout: vector{string}
observation: the vector's backing array can grow, so this array must be allocated via array-new[1], for a pre-computed capacity.

observation: the string's char-array can grow (unlike String.java), so this array must be allocated via array-new.

So the overall memory layout is similar to vector of vector !

Let's assume a capacity of 90 in a 64-bit machine.

Does the vector hold pointers to string? No. An array of 90 pointers require 720 bytes, but an array of 90 strings take 32*90 bytes.

So the memory layout is an dynamic array of 90 "shells" (not 90 pointers). Each shell holds a pointer to a char-array on heap.

[1] or malloc

-- update bookkeeping data for malloc
Some compilers (Microsoft etc) even save file name and line number details in the bookkeeping for each malloc chunk.

-- new: void pointer in C: primitive generic container
[[Understanding and Using C pointers]] P191 has a use case of a void pointer. Void pointers are rarely needed, so this is one interesting example in a reputable book. The use case is a generic linked list. 

The payload is a (presumably heap) pointer. So a sizeof(Node) doesn't include sizeof(payload on heap). This way, the sizeof(Node) is known to compiler. I think java linked list is similar in memory layout.

There are "methods" associated with the LinkedList struct... a basic class.

Encapsulation .. achieved with fwd declaration of Node struct and LinkedList struct in a shared header

To use this linked list, ApplicationA could pass Account pointers as the payload. ApplicationB could pass a Teacher pointer as payload. Both would match the void pointer in Node declaration. 

-- new
[[understanding and using C pointers]] P194 had a sidebar warning that Understanding how memory is allocated for a class instance is key to understanding inheritance and apolymorphism in OO. 

Well, java OO, python OO, php/javascript OO do not require this low-level allocation knowledge at all. Java OO requires this knowledge only for QQ interviews.

The book author is has a low-level C/c++ perspective.

-- pointer usage in threading
In a C++ thread, a pointer could point to heap, to static memory region, to another call stack (another thread) or another stackframe on the same call stack

In java, pointers always points to heap.

-- new: iterators in c++^py^java
Iterator is one of the best examples of abstraction. Java uses interface to support such abstractions. Python uses protocols. C++ is more complex.

I feel the more high-level or newer languages tend to emphasize convenient iteration over efficiency.

stream iterator .. unique to c++
iterating over a text file .. easy in python. 
Iterator invalidation .. unique to c++
fail-fast iterator .. unique to java
infinite-series iterator .. is easy for python's yield, and also supported in std::ranges 
C# also has some special features, but I won't cover them.


-- new: 
many authors esp. in C/C++ warn readers "non-standard, platform dependent feature .. not guaranteed to work. Testing required."

Venkat of OC said "If this feature is not in the c++ standard then you can't rely on it." I disagree. Compiler vendors don't remove or modify any feature for no reason. 

In general, software makers are not bound by any industry standard. Many of the world's most reliable softwares reach less than 99.99% compliance with published standards. That includes operating systems, compilers, RDBMS, CPU instruciton sets, communication protocols.

(In telecommunications, China often invents its own standards).

In reality, if you stick to a fixed version of compiler, on a fixed OS version, then any platform-dependent feature will continue to work. 

A "bug" in a non-standard portion of a library, a compiler or a host application are sometimes retained for decades, esp. when generations of develoeprs have grown used to it.

How about upgrading your local installation? Those features can break. Well, such upgrades always require regression-testing even if you keep within standard features. Those features may not be 100% fully supported by a vendor. That support may change from release to release. The feature itself may undergo changes in the standardar documents. 

-- new java stack
Stack.java is not deprecated but Deque.java inerface is a recommended replacement. However, I think Stack has a cleaner interface with fewer unwanted API methods.

.. Here is an advice from a Comp science professor to students in [[ThinkDataStructure]]

LinkedList.java implements both the Deque.java and List.java interfaces. 

If you declare a lnked list as a Deque<Str> variable, you can't use the List methods.

If you declare a lnked list as a List<Str> variable, you can't use the Deque methods.

If you declare a lnked list as a LinkedList<Str> variable, you can use all methods but your code can become confusing and error-prone. 

-- fuxi blogpost on VLA
Both alloca() and VLA allocate in the stackframe of current function (or a block).

malloc() is an older alternative to VLA but key difference is deallocation. Like alloca(), VLA has automatic storage so deallocation happens automatically at end of block. 

sizeof on VLA executes at runtime. 

-- new: free() and footprint@pid
If malloc() allocates 16M, then free() would (use the bookkeeping info to) return the same amount of memory, usually to the free list. The free list is managed by the DMA library and private to the current process, not shared with another process. 

[[Understanding and using C pointers]] points out that this 16M is not returned to the host OS and available to other processes. Therefore, the memory footprint of the current process doesn't reduce due to free().

-- new
iterator comparison makes sense only when the 2 values point into a sequence container.
The comparison is modelled after "pointer comparison" which is meaningful in an array.

You can subtract itr1 from itr2. The result is a difference_type. See https://www.cplusplus.com/reference/iterator/iterator_traits/ This is modelled after ptrdiff_t for pointer 

--fuxi: pointer to function is a C concept. You can use method reference in python. In all cases, there is a unique address to each named function. That address is in the text segment

--new or fuxi: c++ range seems to borrow from python q[yield]. (I guess c# [yield] may be similar but I don't have time to study it.)
However, c++ range, as a STL extention, seems to rely on an underlying container.

ranges are based on iterators/containers. 

The infinite range doesn't rely on a container but seems to be a secondary feature.

Will C++ range become IV-hot? If it does then I will study.

-- new or udpate "unexpected"
c++ exception specification is removed in c++17. Remember that any exception unlisted triggers "unexpected". Those features [set_unexpected(), unexpected_handler] are also removed.

std library removed bind1st etc, binary_function etc in c++17

See https://mariusbancila.ro/blog/2018/07/05/c17-removed-and-deprecated-features/

-- new: closest ancestors of c/c++
For c++
#1 is C
#2 is Simula

For C #1 is the B language

-- new: whenever you notice "private" keyword, think of "friend". Private/friend are an inseparable pair of keywords.
Similarly, every time you see "cosnt", think of const/mutable pair. Inside classes, private is more useful than const.

-- new: wrapper struct over container elements
Sometimes I need to construct a wrapper instance holding some kind of readonly-reference-to-element-in-container.

Do you want to hold raw pointers to the element?
Do you want to hold smart pointer? No!
Do you want to hold subscript into the container?
Do you want to hold iterators into the container?

If subscript is stable, then I think it is the cleanest design. This would be the case for array-like containres that are somehow constrained to avoid deletion/reallocation.

The problem with a pointer field is ... a can of worm. Whoever reading the code would brace themselves because a pointer field often entails ownership, clean-up, customized copy operation...

The iterator solution is more advanced, can be viable iFF the iterator is guaranteed stable. That depends on the iterator invalidation rules. See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=15251&action=edit. I think the advantage is itr-based insertion into the host container.

-- new: string pbref^pbclone: cpp++
In java and c#, string objects are always passed by reference. 

An extreme example is instructional ... consider a huge string object with 999 trillion characters. In java and c# this object is passed around without cloning the content. A cloning process is expensive.

In C, a cStr is an array, either on heap or elsewhere. It is often passed by pointer (pbref). Pbclone is common when the length is small. In C, string length is usually known in advance. 

In C++, std::string is often pbclone but it can be pbref. Overall, Passing std::string is more complicated than in other languages. 

Inside many c/c++ structs I have seen, string fields are often represented as a fixed-length char-arrays without terminating null char. Note compilers require that fixed length to be a compile-time constant, to support sizeof(). I think this design is industrial strength. It is based on a widespread "KnowYourData" principle... the string lengths should be fairly consistent and the max length known in advance.

An alternative design would use a std::string field. This is feasible, but not popular. There are many subtle complexities
* copying would clone the string
* dtor would destroy the string along with the char-array on heap
* someone will try to get the address of this string field and pass it around. No such complexity exists in the earlier design.

-- BitMain
Q: in your java project, is memory an issue?

--update blogpost on array^ptr
The equivalence is strongest in argument passing. An array ptr degenerates to a ptr parameter. When you pass an array as an argument, it is nothing but a pointer.

However, passing vector (or std::string) is very different. 

-- fuxi or new:
Signal is always asynch, never immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.

--fuxi
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency.
Low latency sockets don't rely on signals for immediate action

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!

-- fuxi: set in python
set is the least used builtin container. I seldom use it, becasue dictionary is always richer.
( Similarly, list is always richer than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset
