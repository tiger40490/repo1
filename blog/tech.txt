-- new or fuxi:
listComp, lambda, interactive shell ... have something in common: the Expression part is the centerpiece. It creates a return value.

-- new: set in python
set is a builtin data type, but I seldom use it, becasue dictionary is always more useful.
( Similarly, list is always more useful than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset

-- update blogpost on java functors
Only in java is the rule very simple and clean -- FCC functions passed into a HOF must be objects.

c++, c# and py are more flexible and less simple

-- new: java Future::cancel(boolean mayInterruptIfRunning)
java Future::cancel(boolean mayInterruptIfRunning) would probably use interrupt to cancel a running thread.

If the boolean arg is false, then the thread is not interrupted and would continue running.

I think pthreads define cancellation points, similar to java's interrupt points.

-- new: precedence: NOT > AND > OR
Proposition 1: Dinosaur existed
Proposition 2: speed kills

Not P1 AND Not P2 means (Not P1) and (Not P2), with or without the parentheses.

Same in any language.
-- new or .. value of real work experience
This value is lowest in concurrency design (and implementation).
Probability of observing a bad race is extremely low, so real world experience of "millions of tests" or "decades of successful operation" often gives a false sense of reassurance.

Correct design depends on peer review, which is based on the guarantee provided by the underlying infrastructure. When one of the underlying specifications changes, the correctness may be compromised without us knowing. 
-- fuxi
in GMDS, catcha mail .. a greenfield design needs to focus on the show-stopper aspects like crashing, instrumentation.

latency is not really a practical focus.

-- fuxi: These new "infrastructure" technologies are not reliable and fooolproof as traditional infrastructure technologies.
eg(big): wordpress block editor
eg: show-stopper: oversensitive touchpad 
eg: show-stopper: home wifi issues
eg: github new policies
eg: wechat issues
eg: wordpress take-down notice
eg: windows license expiry
eg: windows update kick-in at the wrong time
eg: Citrix issues
eg: M1 and starhub blackout

-- update blogpost:
factorial is usually the worst time complexity in any problems.
2^(N!) is worse but don't show up in any problem I know.

--fuxi
signals in windows?

real time signals are a new Posix concept... not really low-latency.

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

-- update blogpost on wpch
installation fear of risks is much lower when installing wordpress upon a working XAMPP.
The more low-level, the more uncertainties.

--update on placement new
I think placement new has two distinct usages
1) for data types with a ctor, it lets you construct those objects (or arrays thereof) at a given heap location without malloc

2) for primitive types like int, it informs the compiler to treat the raw memory as "int", without malloc.

2b) If you call placmeent new with an initializer then it also performs initialization at a heap location without malloc


--new: getsockopt() optLen: api design technique
Based on P44 [[tcp/ip sockets in C]]
getsockopt() last parameter is optlen. This is an in-out pointer parameter.

* As input, it indicates the size of a buffer that would receive the output. "Hey Holywood, here my optLen is a size describing how many bytes you can write into my buffer."

* As output, it indicates the size of a buffer containing the output. "Hey caller, here optLen is a size describing how many bytes I have written into your buffer."

Becasue of the in-out usage, optLen is a pointer. If only as ouput, it can be a return value. If only an input it should be a nonref, or in some cases a ptr-to-const.

Note the buffer can be on stack.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!
--fuxi but no point publishing:
To find a windows service name

  sc query > some.log

To fine the pid of the service name

  sc queryex WinDefend

  taskkill /F /PID 4168
  
--fuxi
Now I realize BFT is by level i.e. visit order is root to leaf. DFT is bottom-up

--new untitled
95G offer service used tibrv to send updates to GUI. Robust and fast. 
(MLP also uses messages to update GUI)

Also there was one daemon instance for each trading account. Sounds inefficient but actually acceptable scalability.

--new: mirrored delegate method
In the json loader project, when I refactored an overgrown method, I often extracted part of it into a “delegate” method or a helper method.

This delegate method is invoked from nowhere but the original method. It can have the same method name (but belonging to different classes), same signatures, sometimes in the same or another file. 

The identical name between both methods is a tell-tale sign of their relationship.

If the original method thus becomes very simple, then we refer to it as a wrapper. 

If the original method is non-static, then the delegate method could be static and stateless... best practice.

It is possible to have original methA calling delegate methB which calls another delegate methoC, if methodC is reusable

A more common extraction procedure creates a reusable routine that’s invoked from multiple places -- DRY
--
Impact cache updates -- can use IP multicast?

--update blogpost on clone()
clone() is needed for immutable design, a hot topic for core java IV. 
However, clone() is not well known or well quizzed

clone() is far more obscure than c++ copy ctor

ImmutableComposite can have field objects that are mutable types iFF they are clonable.

--fuxi:
Citrix became very slow when I moved to a location far from the wifi hotspot. I could see the signal strength dropping very low.

--fuxi: JVM remote debugging is not so foolproof.
GDB is not so foolproof. See my blogposts.

We need to fully embrace the reality that live debugging is often impractical.

In contrast, "echo" is the gold standard in code tracing.

--fuxi: 5GHz ^ 2.4GHz wifi
Range favors lower frequency. Bigger homes may need it.

bandwidth favors higher frequency. Video streaming.

Overcrowding in 2.4 can cause intermittent connectivity issues, but is it 5% of the time or 0.05% of the time? Not sure. Microwave did hit me.

--new: java clone() usage
java clone() is needed mostly in one context -- immutable composite class
This topic is relevant in IV.

If you design a composite class (ImmComp) to be immutable, where some field is of type CC, then you need to clone each CC object received or returned from ImmComp. Remember the 2010 Citi muni interview.

Aha -- if ImmComp can be refactored to hold primitve/string fields of CC rather than a CC field, then things are simpler. CC needs no clone() 
Aha -- if CC is already an immutable class then things are simpler. We probably don't need clone()

Warning: CC could be the root of an object graph such as a tree. When we clone CC and CC contains a field of type DD, then a mutable DD would be part of CC's object state, and also ImmComp's object state. Any change to DD would break immutability of ImmComp :(

-- new: stop/suspend/resume/destroy in java
Occassional IV question, but relatively low market value

These four methods are still part of the API, and stop/suspend/resume are implemented and available. (destroy() is never implemented.) They are all unsafe mostly for two reasons

1) suspend() forces the thread to suspend without releasing locks if any. Susceptible to deadlock. The resume() method is used with suspend().
2) stop() forces the thread to die and release all locks. No deadlock risk AFAIK, but if the thread was forced to release a lock, then the lock is likely needed to protect some object state (such as fund transfer). Force-Release of the lock would expose those object's invalidate state.

--fuxi: python: hasSameContent(dict1, dict2): return dict1 == dict2 

--fuxi
Low latency on a multi-core machine would probably use a lot of threads in STM

Synchronization is the bread-n-butter of multi-threading. as a skill it is all about shared mutable -- improving performance in the presence of shared mutables. However, low latency avoids shared mutables.

See Doug Lea for a broader perspective

--new: untitled
is malloc a kernel service, syscall or a userland function offered in a regular library?

Can I implement my own DAM without involving the kernel? I would say some kernel sys call is needed.

Is there a cpu instruction for heap allocation? Does cpu care about heap vs stack? 
Can check my linux book or google on brk()

--fuxi:Martin's low-latency java talk
My Questions
Q: for low latency should we avoid concurrency ?
A: yes
%%A: parallel processing in ST-Mode is good but avoid any form of synchronization 

Q: If I don’t use heap, and only use stack and static memory….?
A: heap allows sharing between threads

Q: why is JIT not available to c++?
%%A: c was not designed for JIT and ineffective 

