-- c++ range seems to borrow from python q[yield]. (I guess c# [yield] may be similar but I don't have time to study it.)
However, c++ range, as a STL extention, seems to rely on an underlying container.

The infinite range doesn't rely on a container but seems to be a secondary feature

-- new or udpate
c++ exception specification is removed in c++17. Remember that any exception unlisted triggers "unexpected". Those features [set_unexpected(), unexpected_handler] are also removed.

std library removed bind1st etc, binary_function etc in c++17

See https://mariusbancila.ro/blog/2018/07/05/c17-removed-and-deprecated-features/

-- new: closest ancestors of c/c++
For c++
#1 is C
#2 is Simula

For C #1 is the B language

-- update: https://btv-gz.dreamhosters.com/2009/12/11/pureconcrete-virtual-functions/
Pure virtual dtor is one standard idiom to make the host class B abstract. To use this class you must instantiate a subclass D.
[[moving from c to c++]] P404
A body of this dtor is still required at runtime when a D instance is destructed, so you must provide a definition for ~B() but keep it pure virtual. 

Q: How is such a concrete pure virtual different from a concrete virtual? 
A: subclass D inherits a pure virtual dtor and must concretize it to become a concrete class.

--update the 7 requirements of late binding in c++
the virtual function's call site is NOT inside a ctor/dtor

-- fuxi: tech books beat online browsing in some situations like learning a new language. The book is more comprehensive than multiple sites combined.

-- new: multiset, multimap
In multimap, one key maps to a bag of payloads. The payloads can be duplicates, same as in "anyMap" containers.

I think a reasonable implementation is {keyObject -> list of payloads}

In multiset, multiple distinct elements can appear equivalent. They could differ by non-essential attributes like creationTime. 

Some people assume multiset can be represented as {keyObject -> count}, but such a container can't contain two equivalent-yet-distinct keyObjects.

I think a reasonable implementation is treeSet{list{payloads}}.

-- new: whenever you notice "private" keyword, think of "friend". Private/friend are an inseparable pair of keywords.
Similarly, every time you see "cosnt", think of const/mutable pair. Inside classes, private is more useful than const.
-- new: memory layout: vector{string}
observation: the vector's backing array can grow, so this array must be allocated via array-new[1], for a pre-computed capacity.

observation: the string's char-array can grow (unlike String.java), so this array must be allocated via array-new.

So the overall memory layout is similar to vector of vector !

Let's assume a capacity of 90 in a 64-bit machine.

Does the vector hold pointers to string? No. An array of 90 pointers require 720 bytes, but an array of 90 strings take 32*90 bytes.

So the memory layout is an dynamic array of 90 "shells" (not 90 pointers). Each shell holds a pointer to a char-array on heap.

[1] or malloc

-- new: wrapper struct over container elements
Sometimes I need to construct a wrapper instance holding some kind of readonly-reference-to-element-in-container.

Do you want to hold raw pointers to the element?
Do you want to hold smart pointer? No!
Do you want to hold subscript into the container?
Do you want to hold iterators into the container?

If subscript is stable, then I think it is the cleanest design. This would be the case for array-like containres that are somehow constrained to avoid deletion/reallocation.

The problem with a pointer field is ... a can of worm. Whoever reading the code would brace themselves because a pointer field often entails ownership, clean-up, customized copy operation...

The iterator solution is more advanced, can be viable iFF the iterator is guaranteed stable. That depends on the iterator invalidation rules. See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=15251&action=edit. I think the advantage is itr-based insertion into the host container.

-- new: string pbref^pbclone: cpp++
In java and c#, string objects are always passed by reference. 

An extreme example is instructional ... like a huge string object with 999 trillion characters. In java and c# this object is passed around without cloning the content. A cloning process takes forever.

In C, a cStr is an array, either on heap or elsewhere. It is often passed by pointer (pbref). Pbclone is common when the length is small. In C, string length is usually known in advance. 

In C++, std::string is often pbclone but it can be pbref. Overall, Passing std::string is more complicated than the other languages. 

Inside many c/c++ structs I have seen, string fields are often represented as a fixed-length char-arrays without terminating null char. Note compilers require that length to be a compile-time constant, to support sizeof(). I think this design is industrial strength. It is based on a widespread "KnowYourData" principle... the string lengths should be fairly consistent and the max length known in advance.

An alternative design would use a std::string field. This is feasible, but not popular. There are many subtle complexities
* copying would clone the string
* dtor would destroy the string along with the char-array on heap
* someone will try to get the address of this string field and pass it around. No such complexity exists in the earlier design.

-- BitMain
Q: in your java project, is memory an issue?

-- fuxi or new:
Signal is always asynch, never immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.

-- update blogpost on IPC https://stackoverflow.com/questions/14973942/tcp-loopback-connection-vs-unix-domain-socket-performance shows that UDS outperform loopback TCP sockets

-- fuxi: uniqPtr MktVal imt sharedPtr
.. due to move-semantics, which is a hot favorite IV QQ topic

--fuxi
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency.
Low latency sockets don't rely on signals for immediate action

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!

-- fuxi: set in python
set is the least used builtin container. I seldom use it, becasue dictionary is always richer.
( Similarly, list is always richer than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset
