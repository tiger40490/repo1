
-- update https://btv-gz.dreamhosters.com/2021/01/29/ccomposite-arrays/
The pattern: RAII is meaningful only for a class with a custom dtor. The dtor should clean up some resources, usually via a resource handle implemented as a heap ptr. 

Consider a simple struct B with fields and a synthesized dtor.

Q1: Is there a meaningful RAII in a vector of B?
A: Yes vector's internal array is on heap. Destructing the vector would deallocate the array elements i.e. individual B instances. The B dtor is not really part of RAII.

Q2: Is ther a meaningful RAII in a vector of B pointers to heap?
A: memory leak ! the vector dtor would destruct each element, but the dtor for a ptr is noop, not operator-delete :( 
A: to prevent memory leak, you need vector of RAII smart pointers.

Q3: what if B has a pointer to some heapy thingy?
A: then B dtor should be customized for RAII. A1 / A2 still apply

-- new pre-sized std::vector
First we had fixed arrays. Then we had VLA. Then we had malloc arrays. I think fixed-sized std::vector is the upgrade from malloc array.

It offers RAII clean-up.

It offers copy and move support, so you can pass it into/out of function.

-- new: memory layout: vector{string}
observation: the vector's backing array can grow, so this array must be allocated via array-new[1], for a pre-computed capacity.

observation: the string's char-array can grow (unlike String.java), so this array must be allocated via array-new.

So the overall memory layout is similar to vector of vector !

Let's assume a capacity of 90 in a 64-bit machine.

Does the vector hold pointers to string? No. An array of 90 pointers require 720 bytes, but an array of 90 strings take 32*90 bytes.

So the memory layout is an dynamic array of 90 "shells" (not 90 pointers). Each shell holds a pointer to a char-array on heap.

[1] or malloc

-- new: void pointer in C: primitive generic container
[[Understanding and Using C pointers]] P191 has a use case of a void pointer. Void pointers are rarely needed, so this is one interesting example in a reputable book. The use case is a generic linked list. 

The payload is a (presumably heap) pointer. So a sizeof(Node) doesn't include sizeof(payload on heap). This way, the sizeof(Node) is known to compiler. I think java linked list is similar in memory layout.

There are "methods" associated with the LinkedList struct... a basic class.

Encapsulation .. achieved with fwd declaration of Node struct and LinkedList struct in a shared header

To use this linked list, ApplicationA could pass Account pointers as the payload. ApplicationB could pass a Teacher pointer as payload. Both would match the void pointer in Node declaration. 

-- fuxi
[[understanding and using C pointers]] P194 had a sidebar warning that Understanding how memory is allocated for a class instance is key to understanding inheritance and apolymorphism in OO. 

Well, java OO, python OO, php/javascript OO do not require this low-level allocation knowledge at all. Java OO requires this knowledge only for QQ interviews.

The book author has a low-level C/c++ perspective.

-- fuxi: pointer usage in threading
In a C++ thread, a pointer could point to heap, to static memory region, to another call stack (another thread) or another stackframe on the same call stack

In java, pointers always points to heap.

-- new: iterators in c++^py^java
Iterator is one of the best examples of abstraction. Java uses interface to support such abstractions. Python uses protocols. C++ is more complex.

I feel the more high-level or newer languages tend to emphasize convenient iteration over efficiency.

stream iterator .. unique to c++
iterating over a text file .. easy in python. 
Iterator invalidation .. unique to c++
fail-fast iterator .. unique to java
infinite-series iterator .. is easy for python's yield, and also supported in std::ranges 
C# also has some special features, but I won't cover them.

-- new: 
many authors esp. in C/C++ warn readers "non-standard, platform dependent feature .. not guaranteed to work. Testing required."

Venkat of OC said "If this feature is not in the c++ standard then you can't rely on it." I disagree. Compiler vendors don't remove or modify any feature for no reason. 

In general, software makers are not bound by any industry standard. Many of the world's most reliable softwares reach less than 99.99% compliance with published standards. That includes operating systems, compilers, RDBMS, CPU instruciton sets, communication protocols.

(In telecommunications, China often invents its own standards).

In reality, if you stick to a fixed version of compiler, on a fixed OS version, then any platform-dependent feature will continue to work. 

A "bug" in a non-standard portion of a library, a compiler or a host application are sometimes retained for decades, esp. when generations of develoeprs have grown used to it.

How about upgrading your local installation? Those features can break. Well, such upgrades always require regression-testing even if you keep within standard features. Those features may not be 100% fully supported by a vendor. That support may change from release to release. The feature itself may undergo changes in the standardar documents. 

-- new java stack
Stack.java is not deprecated but Deque.java interface is a recommended replacement. However, I think Stack has a cleaner interface with fewer unwanted API methods.

.. Here is an advice from a Comp science professor to students in [[ThinkDataStructure]]

LinkedList.java implements both the Deque.java and List.java interfaces. 

If you declare a lnked list as a Deque<Str> variable, you can't use the List methods.

If you declare a lnked list as a List<Str> variable, you can't use the Deque methods.

If you declare a lnked list as a LinkedList<Str> variable, you can use all methods but your code can become confusing and error-prone. 

-- fuxi blogpost on VLA
Both alloca() and VLA allocate in the stackframe of current function (or a block).

malloc() is an older alternative to VLA but key difference is deallocation. Like alloca(), VLA has automatic storage so deallocation happens automatically at end of block. 

sizeof on VLA executes at runtime. 

-- fuxi
iterator comparison (beyond equality) makes sense only when the 2 values point into a sequence container.
The comparison is modelled after "pointer comparison" which is meaningful in an array.

You can subtract itr1 from itr2. The result is a difference_type. See https://www.cplusplus.com/reference/iterator/iterator_traits/ This is modelled after ptrdiff_t for pointer 

--fuxi: pointer to function is a C concept. You can use method reference in python. In all cases, there is a unique address to each named function. That address is in the text segment

-- BitMain
Q: in your java project, is memory an issue?

-- fuxi or new:
Signal is always asynch, never immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.

--fuxi
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency.
Low latency sockets don't rely on signals for immediate action

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!

-- fuxi: set in python
set is the least used builtin container. I seldom use it, becasue dictionary is always richer.
( Similarly, list is always richer than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset
