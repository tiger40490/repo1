-- update eviction.py
I should convert the dict back to array, and have a single continuous fwd scan, to replace the outer while loop

-- new: multiset, multimap
In multimap, one key maps to a bag of payloads. The payloads can be duplicates, same as in "anyMap" containers.

I think a reasonable implementation is {keyObject -> list of payloads}

In multiset, multiple distinct elements can appear equivalent. They could differ by non-essential attributes like creationTime. 

Some people assume multiset can be represented as {keyObject -> count}, but such a container can't contain two equivalent-yet-distinct keyObjects.

I think a reasonable implementation is treeSet{list{payloads}}.

-- new: memory layout: vector{string}
observation: the vector's backing array can grow, so this array must be allocated via array-new[1], for a pre-computed capacity.

observation: the string's char-array can grow (unlike String.java), so this array must be allocated via array-new.

So the memory layout is similar to vector{vector} !

Let's assume a capacity of 90 in a 64-bit machine.

Does the vector hold pointers to string? No. An array of 90 pointers require 720 bytes, but an array of 90 strings take 32*90 bytes.

So the memory layout is an dynamic array of 90 "shells". Each shell holds a pointer to a char-array on heap.

[1] or malloc

-- new: wrapper struct over container elements
Sometimes I need to construct a wrapper instance holding some kind of readonly reference to an element in a container.

Do you want to hold raw pointers to the element?
Do you want to hold smart pointer? No!
Do you want to hold subscript into the container?
Do you want to hold iterators into the container?

If subscript is stable, then I think it is the cleanest design. This would be the case for array-like containres without deletion or reallocation.

The problem with a pointer field is ... a can of worm. Whoever reading the code would brace themselves because a pointer field often entails ownership, clean-up, customized copy operation...

The iterator solution can be viable iFF the iterator is guaranteed stable. That depends on the iterator invalidation rules. See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=15251&action=edit

-- new: string pbref^pbclone: cpp++
In java and c#, string objects are always passed by reference. 

An extreme example is instructional ... like a huge string object with 999 trillion characters. In java and c# this object is passed around without cloning the content. A cloning process takes forever.

In C, a cStr is an array, either on heap or elsewhere. It is often passed by pointer (pbref). Pbclone is common when the length is small. In C, string length is usually known in advance. 

In C++, std::string is often pbclone but it can be pbref. Overall, Passing std::string is more complicated than the other languages. 

Inside many c/c++ structs I have seen, string fields are often represented as a fixed-length char-arrays without terminating null char. Note compilers require that length to be a compile-time constant, to support sizeof(). I think this design is industrial strength. It is based on a widespread "KnowYourData" principle... the string lengths should be fairly consistent and the max length known in advance.

An alternative design would use a std::string field. This is feasible, but not popular. There are many subtle complexities
* copying would clone the string
* dtor would destroy the string along with the char-array on heap
* someone will try to get the address of this string field and pass it around. No such complexity exists in the earlier design.

-- BitMain
Q: in your java project, is memory an issue?

-- fuxi or new:
Signal is always asynch, never immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.

-- research: unix domain sockets vs sockets to localhost

-- fuxi: uniqPtr MktVal imt sharedPtr
.. due to move-semantics, which is a hot favorite IV QQ topic

--fuxi
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency.
Low latency sockets don't rely on signals for immediate action

Most signals are self-sent from the same process. I think timer alarm is one. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

--fuxi: sys call is not always hardware related. my linux book has a section on sys calls related to signals!

--research: malloc != syscall
is malloc a kernel service, syscall or a userland function offered in a regular library?

Can I implement my own DAM without involving the kernel? I would say some kernel sys call is needed.

Is there a cpu instruction for heap allocation? Does cpu care about heap vs stack? Yes the CPU cares about the stack. There are dedicated stack-registers in the CPU
whilst the stack space is managed via the CPU, the heap is not managed automatically. The size of the heap can also be considerably larger than the stack and the allocation of memory must be performed manually within a program. Memory also has to be freed manually, again unlike the stack.

Can check my linux book or google on brk()

-- fuxi: set in python
set is the least used builtin container. I seldom use it, becasue dictionary is always richer.
( Similarly, list is always richer than tuple, except when used as dict keys. )

One advantage of set over dict or list -- set-comprehension to create a hashset
