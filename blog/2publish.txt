try to sleep early and get up early

==update blogpost: gap behind better speed coders
Any Low-hanging fruits?

Any Path of least resistance? 

Here are my self-rating:
-- "B+" some elegant algos, clear mental picture, 抓要领 -- Am not far behind
-- "B" algo QQ... XR's focus.
Can be improved by focus, accu and mileage.
-- "C" syntax of about 500 common operations. py is easier than c++
-- "D" ECT speed.. my most visible weakness
-- "B" speed coding involving common algos + ECT + syntax

===
--new blogpost: %%traction: QQ/whiteboard/algo/SDI imt speed coding
--update blogpost https://bintanvictor.wordpress.com/wp-admin/post.php?post=27609&action=edit
What part of coding drill is worst on my absorbency?
What type of coding drill can I do for hours like reading/blogging?
implementation is worst. 
It drains my laser energy fastest. 
I think frustration is the key. 
Expectation and self-image create the frustration and the drain. 
Deepak self-identify as "annoyed"

In contrast,
* concurrency coding questions are less draining as other guys are not faster
* pure algo on paper is lighter. No ECT so I am swift and efficient
* SDI is most fun, least boring. I feel a bit of accu 
* c++/java language feature experiments are more interesting as there's no time-line no benchmark. Also other guys are not stronger. I feel some accu exactly like reading on these me features
* review of my previous code is much less draining (than writing new solutions) as there's no time-line and code is already working

Can we stop comparing with others and just compare with our past? Hard

--new new blogpost speed-reading^slow-digestion@legacy code
speed-reading (Understanding big/small program quickly) ... is my competitive weakness, but once I understand a codebase I am often more proficient (and deeper, more complete grasp) than co-workers, capable of precision laser surgery :)

Andrew Yap, Ashish Singh, ... all faster speed reading.

I need to take many notes and refresh them, but still poor retention rate.

Debugging my own code is easier than debugging other people's code. This is more obvious for me than other guys

As part of ECT capacity in speed coding... if I have to read lengthy error messages, I'm slower than other guys. That's why I prefer python.
--eng:
oppo=opportunities

