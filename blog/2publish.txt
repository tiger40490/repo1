--new blogpost: new problems!=the best drill
i used to focus on how many new problems solved each week, but that's very challenging and not necessarily most effective.

Reviewing existing code is easier, but can still take hours. 
Worth the time! 
Am growing stronger than before and stronger than my peers who don't invest the time. They forget what they learned ! No one can remember so well without refresh
====balloon burst DP optimization #50%
Q[L312]: not really classic : Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array "nums". You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

If you burst a leftmost balloon, you collect 1*it*rightNeighbor coins. In other words, when multiplying 3 numbers, any absentee is a one.

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
            coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
int-array optimization problem.
Might be related to some classic problem.

Let's define a generic math-function of 3 balloon IDs score(myle, me, myri). In this problem, score() is simply "return myle*me*myri ", but in the next problem, score() could be any math function of the three inputs. 

I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. Exactly 2^N nodes in the grid, i.e. 2^N possible snapshots i.e. 2^N combinations of these N balloons. 

Every edge has a score. To compute the score, we only need the two nodes (snapshots) of the edge to identify the 3 balloons for score(). 

Pyramid -- Let's assume at bottom is "origin" i.e. snapshot of the original array ..Level 500; on top is "phi" i.e. snapshot of the empty array .. Level 0. 

The problem transforms into a max path sum problem between these 2 nodes.

--solution-1 DP 
From origin to any given node, there are many distinct paths each with a total score up to that node. If a node has 55 paths to it, the max sum among the 55 paths would be the uprank (upward rank) of the node.

If the node also has 44 paths from phi, the max sum among the 44 paths would be the downrank (downwrd rank) of the node. This is an interesting observation, but not needed in this solution since every edge is evaluated exactly once.

To our delight, uprank of a node AA at Level-5 depends only on the six Level-6 parent node upranks, so we don't need to remember all the distinct paths to AA:). Our space complexity is the size of previous level + current level.

We just need to compute the uprank of every node at Level 6, then use those numbers to work out Level 5.... the Level 4 ... all the way to phi.

If there are x nodes at Level 6 and y nodes at level 5, then there are 6x==5y edges linking the two levels.

Time complexity is O(V+E) i.e. visit every edge.

Level n:   1 node
Level n-1: n nodes
Level n-2: nc2 nodes
      ...
Level 2:   nc2 nodes
Level 1:   n nodes
Level 0:   1 node

Each node at level K has K child nodes above. This graph now suggests the max-path-sum algo (with edge scores), but it might be the only way to solve the problem, like the bbg odometer.

consider a DP algo to update the score at each node at level K, ie the max sum from root till here, via one of the K-1 nodes at level K-1 

But Level 2 has too many (N-choose-2) nodes. Can We prune the tree, from either origin or phi?