-- new: trees as subset of graphs
In math, a tree is an undirected acyclic connected graph.

In comp science, graph edges are usually directed (pointer-based, or edgeList). By the definition, trees are a subset of connected directed graphs where any two nodes are connected by one path exactly.

In both definitions, you won't see any closed loop. When some people present a "deformed tree" having visual loops, it breaks both definitions.

-- new: void pointer in C: primitive generic container
[[Understanding and Using C pointers]] P191 has a use case of a void pointer. Void pointers are rarely needed, so this is one interesting example in a reputable book. The use case is a generic linked list. 

In a link node, the payload is a (presumably heap) pointer. So sizeof(Node) doesn't include sizeof allocation on heap. This way, the sizeof(Node) is known to compiler. I think java linked list is similar in memory layout.

There are "methods" (actually free functions) associated with the LinkedList struct.. giving rise to a basic class.

Encapsulation .. achieved with fwd declaration of Node struct and LinkedList struct in a shared header. Any user code would include the shared header and won't access the Node internals.

To use this linked list, ApplicationA could pass Account pointers as the payload. An unrelated ApplicationB could pass a Teacher pointer as payload. Both pointer types would match the void pointer type declared in Node header. 

-- update blogpost 
GS Hong Kong interviewer said array-based order book can achieve 1000 kmps.
It's easy to whip up a POC showing 1000 kmps, but how about all the real-world requirements in rebus? Your design and implementation will be imperfect and will impact the performance. In the end, will you maintain 1000 kmps?

--update blogpost on array^ptr
The equivalence is strongest in argument passing. An array ptr degenerates to a ptr parameter. When you pass an array as an argument, it is nothing but a pointer.

However, passing vector (or std::string) is very different. 

--update invalidation rules:
[[c++coding standards]] P150 says node-based containres can minimize iterator invalidation

-- update blogpost on IPC https://stackoverflow.com/questions/14973942/tcp-loopback-connection-vs-unix-domain-socket-performance shows that UDS outperform loopback TCP sockets

--update the 7 requirements of late binding in c++
the virtual function's call site is NOT inside a ctor/dtor

-- update: https://btv-gz.dreamhosters.com/2009/12/11/pureconcrete-virtual-functions/
Pure virtual dtor is one standard idiom to ensure the host class B is abstract. To use this class you must instantiate a subclass D.
[[moving from c to c++]] P404
A body of this dtor is still required at runtime when a D instance is destructed, so you must provide a definition for ~B() but keep this dtor pure virtual. 

Q: How is such a concrete pure virtual different from a concrete virtual? 
A: subclass D inherits a pure virtual dtor and must concretize it to become a concrete class.

-- new: wrapper struct over container elements
Sometimes I need to construct a wrapper instance holding some kind of stable reference-to-element-in-container.

Do you want to hold raw pointers to the element?
Do you want to hold smart pointer? No!
Do you want to hold subscript into the container?
Do you want to hold iterators into the container?

If subscript is stable, then I think it is the cleanest design. This would be the case for array-like containres that are somehow constrained to avoid deletion/reallocation.

The problem with a pointer field (in wrapper struct) is ... a can of worm. Whoever reading the code would brace themselves because a pointer field often entails ownership, clean-up, customized copy operation, stray pointer, pointer reseat ...

The iterator solution is more advanced, can be viable iFF the iterator is guaranteed stable. That depends on the iterator invalidation rules. (See https://btv-gz.dreamhosters.com/wp-admin/post.php?post=15251&action=edit ) I think the advantage is itr-based insertion into the host container.

-- new: basis_risk
Alex Tee of Stirt felt basis_risk is a basic common knowledge

P53 [[fundamentals of Fut and Opt markets ]]

-- update blogpost on fwd^fut https://btv-gz.dreamhosters.com/wp-admin/post.php?post=41694&action=edit
P40 [[fundamentals of Fut and Opt markets ]]

-- update one of the 4 blogposts on IRS valuation
P170 [[fundamentals of Fut and Opt markets ]]

-- update blogpost on tibrv wrappers
py, node.js, perl (my first encounter), java, c# ... can somehow operate at a low level such as sockets, shared memory, semaphore, memory fence...
However, they rely on the underlying C API, which is either a system library or related to the kernel.

The amount of programmer-control is much better in C, as C is a naturally low-level language. Those higher languages (including c++ class libraries) use wrappers. 

In these case as in the tibrv wrapper, the mkt val of the C knowledge is higer and more time-honored. The API in C has a very stable evolution.

Most technical discussions over the decades would also focus on the common API in C.
