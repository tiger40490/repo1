-- update FIX JIV questions
FIX may not be so strategic for my career, but I am a FIX developer now and I want to be a self-respected FIX developer.

What can cause overfill?
After an cancel request is sent out or after an order expires, we may receive fills. 

What can cause incoming seq too high/low?

If fills are undelivered for a long time, becuase your FIX gateway is shut down or network issue, will the fills become lost? What can we do?

What if you need to send an urgent cancel but FIX session is busy re-synching sequence number?

Q: What's DK trade (35=Q)?
A: For example, if as buy-side you only sent one order today with ClOrdID = 10 but you received an execution report for ClOrdID = 20, your FIX application should reject this execution report.

EOD for a FIX session? End of Day indicates a reset of sequence numbers to 1/1.

FIX version? Tag #8

Q: what if session disconnected?
A: don't reset sequence. Coordinate with counterparty.

Q: what tags identify symbology used?
A: #55 #48 are often identical. #22 is IDSource

maximum number of characters allowed in a FIX field? 256 chars
maximum number of tags in a FIX message? 4000+

Q: any known security issues with using the FIX protocol?
A: There are no known major security issues with using the FIX protocol. Some generic vulnerabilities exist for any network application -- eavesdropping, tampering 

Q: You placed a new order and then place a replace request and received Pending replace message and then a fill, what would be ClOrdID of the fill?
A: Since OrderCancelReplaceRequest (tag 35=F) is not accepted, ClOrdID of NewOrder will be in force and fill will contain ClOrdID of the NewOrderSingle (35=A). It’s only after your received ExecutionReport with ExecType=Replaced your ClOrdID of the active order gets updated. Pending Replace is just indication that broker or exchange received a Replace Request but not yet accepted or rejected it.

Q: difference between Application level Reject (MsgType=8 and ExecType=8) and Session level reject (MsgType=3)?
A: FixEngine will reject any message which doesn't confirm FIX protocol i.e. some mandatory tags missing e.g. MsgType with Session level reject , the application will not get that message for processing , while application e.g. OMS or Execution System will reject message based on Business logic or FIX (financial information exchange) Protocol trade life cycle with application level Reject (MsgType=8 and ExecType=8).

-- new: GPT
application domains of GPT:

language translation 
document summarization 
building websites, 
designing visuals, 
making animations, 
researching complex topics

How slow is the training? As of 2023, hundreds of billions of Words would take months using supercomputers. Fine-tuing often takes days on smaller computers.

Fine-tuning means ... writing instruction/goodOutput and feeding them.

GPT models generate text in casual, humorous, professional,,,, styles.

Educators can use GPT-based software to generate learning materials such as quizzes and tutorials. Similarly, they can use GPT models to evaluate the answers.

-- update or new: threading in c++ less popular than in java
Concurrency dev is difficult, in both design and the basic building blocks as language constructs. Java makes it easier, much easier than pthreads and std::thread. It is so easy that java interviews routinely include some concurrency questions.

Factor: the c++ shops I try are all trading shops. They choose c++ for latency. To optimize latency, STM is best, rather than multi-threading. So I think their c++ threading questions are light.

-- new: misstep: accidental amend of last pushed commit
frequent mistake:

1) I commit a file on branch3, and git-push
2) I revise recent change and git-commit-amend. This is a misstep, as the new tip of branch3 is a modified version of the origin/branch3. The two branches have divered.
3) when I git-push, I fail

Simple solution: 
1) back up affected files
2) git reset origin/branch3
3) git commit # creates a new commit on top of the origin/branch3 tip
4) git push

-- update [18]proof-of-work ] blockchain
Proof@Stake
Q: what if a big "shareholder" of a ABC coin mishandles a validation, and adds a bad block to the ABC blockchain? 

Does she earn the "gas" before or after the bad data is uncovered?  If "after", then bad data is included in the ABC block chain for at least some time, and during that period, unlimited number of subsequent blocks could go into the blockchain, leading to a mess. So I will assume answer is "before". 

So technically, how can the "second validation" take place in real time? If it is straightforward to detect a bad block, then the first validator would always do it automatically, and there would be no risk of losing your stake. In such a case, every participant would stake 100% of their coins each time. That means the biggest "shareholder" would keep getting richer, and richer.

I believe it's not straightforward to detect a bad block produced by the first validator. That leads to a can of worms.

Suppose there's a dispute... someone disputes a past transaction on the blockchain. Who has authority to question the first validator? Who would be the judge? I think real power ultimately lies with the founders and the software developers. This is not decentralized concensus-building.

-- fuxi
Adaptive (a finIT firm) have worked within many banks and used all the mainstream messaging middlewares available in the industry. Experience has taught us, that peer-to-peer messaging system is more flexible than broker based messaging systems and requires less operational overhead. You don’t need additional servers (or hardware appliances) to use it, which are generally organised as shared infrastructure and become an organisational bottleneck for development teams.

That's the experience of one team. Other teams may say the opposite, based on their experience with diverse MOM solutions.

-- new or update: detect stuck thread in a pool
weblogic marks a pooled thread as stuck if it is busy for 10min (configurable). Weblogic is designed for a large patient queue, so each patient should not take 10min.

For a custom application, this doesn't work. A thread can be busy and productive for any amount of time.

Purpose of detection is not per-patient intervention. Purpose is hospital mgmt such as thread pool config, memory increase, or load balancing.

-- new or update on signal+socket
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency. 
Low latency sockets don't rely on signals for immediate action

Many signals are self-sent from the same process. I think timer alarm is one example. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

Signal is designed to be asynch, seldom immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.
