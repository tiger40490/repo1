-- new: misstep: accidental amend of last pushed commit
frequent mistake:

1) I commit a file on branch3, and git-push
2) I revise recent change and git-commit-amend. This is a misstep, as the new tip of branch3 is a modified version of the origin/branch3. The two branches have divered.
3) when I git-push, I fail

Simple solution: 
1) back up affected files
2) git reset origin/branch3
3) git commit # creates a new commit on top of the origin/branch3 tip
4) git push

-- update: seminar on DS/ML
hiring: DS + finance ... scarce

Engineering is a huge effort in data science team. I think they need devops, rather than C++/java SWE

I think BQuant is a huge investment in DS/ML/AI since 2007.
I think the two BQuant presentations represent the most commercially viable applications of BQuant DS/ML research. Both presentations offer emerging, tantatilizing value propositions. The absence of a more concrete value proposition suggests that AI/ML is still a solution looking for a problem. 

* NLP solution includes a sugar-coating UI to ease the usage of the Bloomberg terminal. The main value-add is a an ingestion engine constantly analysing news articles and applying ML models to tag/index/classify content. Users can perform high-level sentiment analysis.

* intraday order-flow data analytics for pre-trade signal .. see https://btv-gz.dreamhosters.com/40285/ai-predicting-security-price-skeptical/

the Bloomberg API is mostly python, perhaps similar to PyTorch and TensorFlow.

~~ i feel these data scientists are not SWE.. seldom uses compiled language. They are users of a software platform.

java and c# are sometimes considered c/c++ applications. (In the same vein, c++ can be considered a C application since it is built on top of C.) I think this description ignored the fact that java / c# developers do need to worry about low-level details, and can achieve latency comparable to c++.

these data scientists They use scripting languages and high level libraries. I think they might be similar to app developers using Angular.

They might be similar to quants who write c++ code.

However, a data science codebase can be large and complex, just not in the same way as a traditional compiled project.

Does your skill as a c++/java/c# SWE make you a stronger candidate for a data science dev team, compared to a candidate coming from python, javascript, ruby etc? 
Yes but not much.

-- update [18]proof-of-work ] blockchain
Proof@Stake
Q: what if a big "shareholder" of a ABC coin mishandles a validation, and adds a bad block to the ABC blockchain? 

Does she earn the "gas" before or after the bad data is uncovered?  If "after", then bad data is included in the ABC block chain for at least some time, and during that period, unlimited number of subsequent blocks could go into the blockchain, leading to a mess. So I will assume answer is "before". 

So technically, how can the "second validation" take place in real time? If it is straightforward to detect a bad block, then the first validator would always do it automatically, and there would be no risk of losing your stake. In such a case, every participant would stake 100% of their coins each time. That means the biggest "shareholder" would keep getting richer, and richer.

I believe it's not straightforward to detect a bad block produced by the first validator. That leads to a can of worms.

Suppose there's a dispute... someone disputes a past transaction on the blockchain. Who has authority to question the first validator? Who would be the judge? I think real power ultimately lies with the founders and the software developers. This is not decentralized concensus-building.

-- fuxi
Adaptive (a finIT firm) have worked within many banks and used all the mainstream messaging middlewares available in the industry. Experience has taught us, that peer-to-peer messaging system is more flexible than broker based messaging systems and requires less operational overhead. You donâ€™t need additional servers (or hardware appliances) to use it, which are generally organised as shared infrastructure and become an organisational bottleneck for development teams.

That's the experience of one team. Other teams may say the opposite, based on their experience with diverse MOM solutions.
-- fuxi
If a pull request branch can't be rebased onto master, sometimes it can be squash-merged.

-- new or update: detect stuck thread in a pool
weblogic marks a pooled thread as stuck if it is busy for 10min (configurable). Weblogic is designed for a large patient queue, so each patient should not take 10min.

For a custom application, this doesn't work. A thread can be busy and productive for any amount of time.

Purpose of detection is not per-patient intervention. Purpose is hospital mgmt such as thread pool config, memory increase, or load balancing.
-- new: patient Q
good metaphor for thread pool and producer/consumer. The patient queue can be 60,000 in a reasonable design (Weblogic)

-- fuxi:
if a window dosesn't show up even though it is on the taskbar, then it's hidden somewhere. You can press control-shift and rightClick on the taskbar item.

-- new or update on signal+socket
signals in windows? not popular

real time signals are a new Posix concept... not really low-latency. 
Low latency sockets don't rely on signals for immediate action

Many signals are self-sent from the same process. I think timer alarm is one example. Sockets is another example. However, keyboard signals like Ctrl-C are not self-sent.

Signal is designed to be asynch, seldom immediate, though the scheduler may preempt whatever is running and give the next time slice to the signal's target process sooner than normal.

One of the most common signals is SIGSEGV. The default signal handler function performs a core dump. There's no process to preempt. However, the current process may not check its signal table until some instructions later, and then run the signal handler.

-- fuxi: closest ancestors of c/c++
For c++
#1 is C
#2 is Simula

For C, the #1 is the B language. It explains the naming of "C"

-- new: a few minor criticisms of c++
An obscure but simple shortcoming of c++ lies in the iostream. There is a shared mutable global state in the global variables cout (and cerr). Every call to setXXX would permanently update the global state until updated again.

iterator invalidation .. a common gotcha

private methods are exposed in class header files.