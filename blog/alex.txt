Draft 2
----
Hi Alex,

You impressed me in our first encounter and impressed me again. A long and thoughtful reply, appreciated. I'm long-winded and technical, so I have reduced the audience.

1) correctness -- I consider my code 100% correct. All corner cases are tested as far as I can see. My Assumptions section mentions input validations that I left out.

2) coding to spec -- I have already admitted my mistake to forget filename handling. That's the only attention-to-detail issue I see.

As to extraneous output, no code clean-up is needed. Just follow readme and run ./a.out 1>/dev/null.

3) complexity -- design and readability depend on complexity.

A solution written against lower complexity will enjoy readability + cleaner design. So why is my solution more complex? My algorithm, described in readme and move1step(), is simple. It is not efficient, but simple. Its complexity lies in the scenarios (described in readme) and mirror hit-count logic. My algorithm is step by step, as shown in move1step(). I think it's simple but in reality, it could be more complex than alternative algorithms. I am proud of my step-by-step algorithm. It enabled the visual output I sent on 1 Nov. Admittedly, my step-by-step code logic is hard to follow. I believe there is a simpler design but I don't know if that design solves all the scenarios in my readme.

Another complexity lies in header hierarchy and header circular dependency. In my design, 1)dumper.h 2)util.h 3)Grid.h 4)Photon.h form four layers. Higher layer depends on lower layer, never vice versa. To avoid circular dependency, I had to bend over backward and structure things in unnatural ways. If you want a cleaner code, you can be lazy and use forward-declaration or you can make two headers include each other. That's a code smell, but unnoticeable by casual readers.

Another complexity -- dumper.h is a reusable template-based generic container dumper. I copied it from another project. Admittedly, it is complex and overkills for this small project. But put yourself in my shoes. If you have a reusable but complex utility class, would you avoid it for fear of alienating code reviewers?

My latest version is even more complex, less understandable, due to ASCII visualization. Once again, it demonstrates that ambitious, advanced design goals lead to "overcomplicated" designs. Since your developers don't know all of my design goals, they consider the design overcomplicated. Admitted.

Question: if we ask a professional developer to evaluate a source code similar (in design and style) to std::vector, what would the guy say?
My Answer: I think the guy may say "overcomplicated, hard to understand, too many typedefs, why is this or that construct needed in a small thing like a vector...."

The guy says these things because he is not used to the style. STL was designed for efficiency, flexibility, versatility. These priorities are very different from commonplace priorities like simplicity and readability.  STL's code style was unconventional and therefore difficult for many of us. I consider that a drawback in STL. In the same vein, my solution was written for a slightly more complex problem, so it became "overcomplicated" by some standards. Admitted.

Question: if we ask a professional developer to evaluate a non-trivial source code similar to std::vector but the guy thinks the code is broken, what do you expect him to tell you about code quality and design?
My answer: the guy would not bother to understand this difficulty code. He will say it is poorly structured, breaking common design principles. Well STL was unconventional in style indeed. It took a few years for the style to be understood.

( In contrast, if the guy knows the code works Correctly, he would study it more seriously and make out the design and the algorithm. )

In my case, your developers didn't bother to read the readme, didn't run the solution as instructed, and didn't believe my solution has any value. Do you think they would bother to understand the design with its unique complexities? The complexities are non-trivial, even if they follow readme and follow debug output. The debug output was there to help them trace the code, but because they didn't read the readme, the debug output failed my solution. How ridiculous.

If your developers follow the readme
* they would see some correct output
* they would see clues to the algorithm + all scenarios
* they would start to understand the debug output
* they would start to understand the design
* they would give a more in-depth evaluation of code quality and design.

3b) other readability issues:

There's another readability issue -- I use custom data types and invent nouns to model the problem domain. So my code shows lots of strange names:
* Coordinate_t for a coordinate value,
* RowId, ColId for the X-coordinate and Y-coordinate values,
* Cell for a cell in the grid
* Step for the four directions of a ray
* Photon for the advancing tip of a ray
* ttl (time-to-live) for a mirror, which is cleaner than a hit-counter, but I guess your reviewer will likely consider my "ttl" a readability issue!

Those custom types are mostly typedefs of simple c++ types, so they can reduce readability -- Until you spend enough time with these new nouns, they will confuse you rather than guide you. In the long run, I suppose a codebase would benefit from custom types. It's a best practice I learned years ago. In c++ standard library, there are tonnes of typedefs.

Another readability issue -- many code reviewers prefer to see only class declaration in headers. I follow the template coding style, where everything is in headers.

Another readability issue -- I suspect your developers are used to seeing constructors. Constructors can improve readability, but I used quick-n-dirty uniform initialization and default constructors.

Another readability issue -- assertions are uncommon among c++ developers. So if your developers are like my colleagues, then assertions can add lots of noise and hurt readability. My assertion messages are often cryptic. Admitted.

My input parsing was quick-n-dirty, not a clean design. In the readme, I explained why.

Based on second-guessing, I hope to have addressed all the complaints on design and code quality. I'm a deliberate developer. My boss once said, "Every line you wrote, you had a reason, huh?" That's why I probably won't change my design/style without someone explaining why. I don't want to second-guess "Maybe Fenix wants more constructors or fewer assertions".

So far, I have been defensive. Okay, my solution is not the cleanest, most readable, not even close. As I reiterated, correctness is THE overriding priority for me, so I allocated most of my effort to validating program logic.

I appreciate your gesture. I will consider whether to re-submit.