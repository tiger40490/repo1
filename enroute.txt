[e=ez]
[c=classic]
[v=easy to verify]
[g=github]
* Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return ALL such possible sentences. "Harder" than the punctuation problem.
* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
* Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
* [ev] Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
* [v] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
* [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
* [cv] merge two sorted lists
* [c] ring buffer
* SIG movie search in STL
* [c] hash table for single-threaded usage
* [c] Ref counted string [[more eff c++]]
* [c e v] binary tree serialization #Deepak's solution
* [c e v] insertion sort
* [c !e] next split@N boys
* [c !e str] longest palindrome subsequence
* [c str] regex parser with q(?)
* [c graph] find cycle in binary tree
* [c e tree] given 2 nodes in a tree, find the lowest common ancestor.
* [c] Q: rotate a large array (N elements) by K positions. Both N and K are potentially large, so we need 1) time efficiency 2) memory efficiency. Ideally,Â O(1) space and O(N) time.
* [2D] Given a boolean matrix mat[M][N] of size M X N, modify it such that if a matrix cell mat[i][j] is 1 then make all the cells of ith row and jth column as 1.
* [v 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
--[2D] Given a n*n matrix where all numbers are distinct, find the maximum length path (starting from any cell) such that all cells along the path are in increasing order with a difference of 1. We can move in 4 directions from a given cell (i, j), i.e., we can move to (i+1, j) or (i, j+1) or (i-1, j) or (i, j-1) with the condition that the adjacent cells have a difference of 1.

Example:

Input: mat[][] = {{1, 2, 9}
{5, 3, 8}
{4, 6, 7}}
Output: 4
The longest path is 6-7-8-9.
