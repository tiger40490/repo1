[c=classic]
[e=ez]
[g=github]
[L=leetcode]
[v=easy to verify]
Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. No complexity requirement.

====solution:
Maintain a min-heap (or BST) of capacity K, initialized with any K elements. Then start scan. compare top with iterator. iif iterator is strictly bigger then remove the top and insert the iterator pointee in O(logK).

total O(N logK), better than N*logN

In this design, the leading pack (i.e. min-heap) is unsorted and the trailing pack is completely unsorted.
=========
Q[L]: sort a list in O(N logN) but constant space? 

I think swap is way to go, but recursion stack space? iterative?

Q[L]: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
%%A: just compute all pairs. For each pair, flip it and look for it in a hashtable.
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2)...
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?

Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

already solved (?) ... Q [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
(No complexity requirement? I will aim for O(N) time and O(1) space.
%%A: first scan to count EOG (end of group) nodes. Say the last EOG is saved in a var "leog". In 2nd scan, we will adapt our non-recursive algo to reverse each K-group. When we hit leog, we exit.

Q [c e v] binary tree serialization #Deepak's solution
Q [c e v] insertion sort for array
Q [c !e] next split@N boys
Q [c !e str] longest palindrome subsequence
Q [c e tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run a lazy-dft to find the two paths-from-root. On each path, if we detect a cycle we terminate that path. As soon as we find the 2 paths we terminate DFT. 

If two processors are given, my dft will use two threads -- one left to right; the other right to left. This will more quickly locate the 2 target nodes if they appear near extremities.

on a given path need to check if we hit both nodes, so after finding one node we must go all the way to leaf node

Q [Lv 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
Q [c graph] find cycle in binary tree? bft first.
Q [c] ring buffer
Q SIG movie search in STL
Q [c] hash table for single-threaded usage
Q [c] Ref counted string [[more eff c++]]
===== problems below should be posted to blog
