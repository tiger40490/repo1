[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

====Q: pass a temp object to a func(nonref) invoking the move-ctor? No. I was right to predict that compiler optimizes away the temporary

====Q[L] 135) Candy problem (hard). There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:
* Each child must have at least one candy.
* Children with a higher rating get more candies than their (two) neighbors. (I guess no rule about two neighbours with same rating)

What is the minimum candies you must give?

Example 1:

Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
Example 2:

Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. (The third child gets 1 candy because it satisfies the above two conditions. )

--my algo: first scan to find unique ratings. Then lowest kids all get 1. then check their neighbors ... if higher then they get 2. Repeat. After all checks, remaining kids get 1.

====Q[Lv]: Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

-- My O(N) algo {applicable for any-size integers and other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

greedy?

O(1) space probably means swapping
====Q[L]: Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

First, some basic checks:
* If the number + 1 is a power-of-2, then discard the number, as it has almost no effect on the result. (Do keep the largest of these numbers)
* if the number is a power-of-2, then get the power value (a natural number) and use it as array-index to update a special boolean vector.
* Every other number ... I guess need to be converted to a bit vector

====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!

Sol2b: 
Instead of standard partition algo, we can pick two pivot (pivotL, pivotH) and anchor both in one scan. Then discard two of the three segments.

====Q[L]: Given a string containing digits from 2-9 inclusive, return in any order all possible letter combinations (not permutations) that the number could represent.
====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

This question is easy to search online.
====Q [c e v] insertion sort for array
====Q[c !e L]: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
====Q [c !e] next split@N boys
====Q [c !e str] longest palindrome subsequence

====Q [c graph] find cycle in binary tree? See blog https://bintanvictor.wordpress.com/wp-admin/post.php?post=18950&action=edit
====Q [c] ring buffer
====Q SIG movie search in STL
====Q [c] hash table for single-threaded usage
====Q [c] Ref counted string [[more eff c++]]
============= problems below should be posted to blog
----
60% done Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2).... and look up the sum in a pre-populated hash table of M items.
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?
----
90% done Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
----
60% done Q [c e L tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run a lazy-dft to find the two paths-from-root. On each path, if we detect a cycle we terminate that path. As soon as we find the 2 paths we terminate DFT. 

On a given path need to check if we hit both nodes, so after finding one node we must go all the way to the leaf node or the other node.

IIF two CPUs are given, my dft will use two threads -- one left to right; the other right to left. This will more quickly locate the 2 target nodes if they appear near extremities.
