[c=classic]
[e=ez]
[g=github]
[L=leetcode]
[v=easy to verify]
Q Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return ALL such possible sentences. "Harder" than the punctuation problem.
%%A: recurse in a loop? Solvable even if not optimal

Q Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
just compute all pairs. For each pair, flip it and look for it in a hashtable.
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2)...
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?

Q [ev] Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
%%A: a test of impl skill. I would pick the list having the lowest (leading) value as the Yellow jersey (leading). (The other is the green.) 

I always keep a red pointer to the last of the leading pack in the yellow. In the event of a 'swap', the red's current descendants gets detatched and becomes the green list, and the old green list moves into the yellow, and we increment the pointer.

Every time after we increment the pointer, we compare its Next vs the head of the green. 

I won't bother with std::list::splice() and will use python or my own linked list

Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
A: should mark on blog as hard and solved myself

Q [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
(No complexity requirement? I will aim for O(N) time and O(1) space.
%%A: first scan to count EOG (end of group) nodes. Say the last EOG is saved in a var "leog". In 2nd scan, we will adapt our non-recursive algo to reverse each K-group. When we hit leog, we exit.

Q [c e v] binary tree serialization #Deepak's solution
Q [c e v] insertion sort
Q [c !e] next split@N boys
Q [c !e str] longest palindrome subsequence
Q [c e tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run dft to find the two paths-from-root. On each path, if we detect a cycle we terminate the path.

Q [Lv 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
Q [c graph] find cycle in binary tree? bft first.
Q [c] ring buffer
Q SIG movie search in STL
Q [c] hash table for single-threaded usage
Q [c] Ref counted string [[more eff c++]]
Q [L] max in sliding window Q (leetcode hard problem 239):Â Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position, return the max item in it... constant time.

analysis====

feature -- Note each item lives a fixed number of cycles. so insert/delete are both constrained.
feature -- Compare the min-stack. This is a min-queue..
idea -- Compare skyline problem.
idea -- sorted linked list with hm pointing to it for O(1) deletion. For insert? (i'm thinking of binary heap again.) I can efficiently insert above the highest (or 2nd highest) node, or below the lowest (or 2nd lowest).
idea -- can we use the sum?
idea -- fixed capacity binary heap -- is insertion faster than O(logN)?
--------------
Q [L] LFU (Least-Frequently-Used) cache to support the following operations: get and put in O(1)
* get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
* put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

ds -- centry i.e. CacheEntry node {key, value, hitCount, lastHit (timestamp), pointers to prev/next centries, (optional) ptr to host LinkNode}
* invariant: hitCount can only increase

ds -- inner list of centry nodes
* invariant: list sorted by lastHit. We can remove any node, but incoming node is always added to the Tail

ds -- fixed-sized (no rehash) hashtable {key -> ptr to centry}, 

ds -- LinkNode {level, inner list-of-centry, prev/next pointers } where all centry objects share the same hitCount denoted "level".
* invariant: outer list is always sorted by level

ds -- outer list of LinkNodes

when a centry gets a hit, its hitCount goes up. It bubbles up to the next higher LinkNode ((
* remove the centry from old linkNode, 
* append to new linkNode, at Tail of inner list. The new LinkNode could be empty or even non-existent
* optionally, new host linkNode's address is saved in the centry; 
))

Get() hit -- relatively easy. Update the hitCount and bubble up
Get() miss -- trivial
Update -- similar to get-hit
Insertion (after deletion) -- trivil.
Deletion -- always from list to hashtable, never the converse
* identify lowest LinkNode, then delete the head of inner list. O(1)
* when a linkNode becomes empty, it is removed from the outer list, to prevent build-up of consecutive empty LinkNodes leading to linear search for eviction target. Imagine aaaaa bbbbb c[need to evict]. Therefore, array of LinkNode is unacceptable

===== problems below should be posted to blog
