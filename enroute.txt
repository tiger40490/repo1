[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

====Q[L]: Given a continous range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

* the lowest bit will most likely see 0 and 1 so ... becomes zero
* if the range has size > 8 then lowest 3 bits all zeroed out

imagine the object incrementing from m to n. We want to find out if there's a stable higher portion, but we may get a power-of-2 within the range, wiping out the stable...

We can convert m and n to two bit vectors. we can look at some examples below. we can compare the two bit vectors left to right to find the "higher portion". All lower bits are probably zeroed out in the result

10110101
10110100
10110011
10110010
10110001
-----
10110000

--shorter algo
compare m and n left to right. If m is shorter, then find the highest power-of-2 within the range.

if same length, then compare left to right until a difference is found. Until that bit, all leftend bits are "retained".

--My algo
1) determine if there are some power-of-2 within the range. If there is, then find the highest power-of-2. That bit pattern is probably the final result.
From now on let's suppose there's no power-of-2.

2) compare the two bit patterns m and n left to right to find the "stable higher portion"

Now focus on the lower portion. Look at the length of the range sz 

3) if sz is a power-of-2 like 8, then last 3 bits zero out and all other bits are in the stable portion.

4) suppose sz is between 8 and 16, then last 3 bits would zero out. Only need to work out the 4th bit. Just look at the 4th bit in m vs n

====Q[L] 135) Candy problem (hard). There are N children standing in a line. Each child is assigned a rating value. You are giving candies to these children subjected to the following requirements:
* Each child must have at least one candy.
* Children with a higher rating get more candies than their (two) neighbors. (I guess no rule about two neighbours with same rating)

What is the minimum candies you must give?

Example 1:

Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
Example 2:

Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively. (The third child gets 1 candy because it satisfies the above two conditions. )

--my algo: first scan to find unique ratings. Then lowest kids all get 1. then check their neighbors ... if higher then they get 2. Repeat. After all checks, remaining kids get 1.

i find this problem contrived and unclear... to be removed

====Q[Lv]: Given array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

well-defined problem:)
greedy?
O(1) space probably means swapping
mutable?
-- My O(N) algo {applicable for any-size integers and other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!

Sol2b: 
Instead of standard partition algo, we can pick two pivot (pivotL, pivotH) and anchor both in one scan. Then discard two of the three segments. Is this really algorithmically better? I think so since we discard more irrelevant segments faster

====Q[L]: Given a string containing digits from 2-9 inclusive, return in any order all possible letter combinations (not permutations) that the number could represent.
====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

This question is easy to search online.
====Q: pass a temp object to a func(nonref) invoking the move-ctor? No. I was right to predict that compiler optimizes away the temporary. See my experiment in github

====Q [c e v] insertion sort for array
====Q[c !e L]: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
====Q [c !e] next split@N boys
====Q [c !e str] longest palindrome subsequence

====Q [c graph] find cycle in binary tree? See blog https://bintanvictor.wordpress.com/wp-admin/post.php?post=18950&action=edit
====Q [c] ring buffer
====Q SIG movie search in STL
====Q [c] hash table for single-threaded usage
====Q [c] Ref counted string [[more eff c++]]
============= problems below should be posted to blog
----
60% done Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2).... and look up the sum in a pre-populated hash table of M items.
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?
----
90% done Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
----
60% done Q [c e L tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run a lazy-dft to find the two paths-from-root. On each path, if we detect a cycle we terminate that path. As soon as we find the 2 paths we terminate DFT. 

On a given path need to check if we hit both nodes, so after finding one node we must go all the way to the leaf node or the other node.

IIF two CPUs are given, my dft will use two threads -- one left to right; the other right to left. This will more quickly locate the 2 target nodes if they appear near extremities.
