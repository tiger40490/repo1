[c=classic]
[e=ez]
[L=leetcode]
[v=easy to verify]

--It's relatively easy n enjoyable to review some of the classicGenerators problems.
approaches to generator problems
* p2u in next_perm
* append to each vector in a growing collection
* insert into every position in a vector in a collection

====Q[L312]: Given n (up to 500) balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons one by one. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent. Find the maximum coins you can collect by bursting the balloons wisely.

0 ≤ nums[i] ≤ 100

Example: Input: [3,1,5,8]
Output: 167 
Explanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []
             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167
==analysis:
Looks more like math problem than algorithm problem.

array2 -- obvious decision
array3 -- With trough then I can prove we should always burst the trough
if ascending like illustrated, then I can prove the Explanation is aways optimal
if peak? Depends on the left/right. if lr > l+r+1 then should burst the peak. 

Looks like a DP idea.. any optimal substructure?

if there are 2 troughs near the ends, which one to burst or both independently?

--sol1 brute force
I see each possible snapshot (having K balloons, i.e. at level K) as a graph node. 1 Starting node (Level n), n ending nodes (level 1).  Each node has K child or downstream nodes. This graph now suggests brute force but it might be the only way to solve the problem, like the bbg odometer.

But Level 2 has too many nodes. We need to prune the tree, from either start or end

====Q[L]: Q: (Leetcode "hard" Q124) Given a non-empty binary tree of signed integers, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from any starting node to any node in the tree along the parent->child connections. The path must contain at least one node and does not need to go through the root. No uplink

--My solution -- DFT. Along each root-to-leaf path, use the max-subarray (Kadane) algo and store maxSumEndingHere value in each node, for reuse.

first milestone: write and test a function to print every root-to-leaf path

https://bintanvictor.wordpress.com/wp-admin/post.php?post=23360&action=edit

====Q[Lv] : Leetcode problem 17... Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

2: abc
3: def
4: ghi
5: jkl
6: mno
7: pqrs
8: tuv
9: wxyz

Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]. 

--we need good variable names. The utility function would be
set<vector<char>> gen(vector<char> const & lob /*lettersOnOneButton*/ , int repeat)
type alias LOB for vector<char> or possibly a string
To minimize confusion, every digit is immediately mapped to a name string like '2' -> "er" and I hope not to use the digit any more.
222223444 would become {str_button -> bundle {set<vector<char>>, repeat, LOB}} ..{"er"->5 reps ...}

struct Bundle{
  set<vector<char>> club
  size_t repeat;
  LOB lob;
};

Miletone: the map is populated with the clubs. Now generate combos ... better use "append" approach.

====Q[Lv] 50%: Given a continous range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

* the lowest bit will most likely see 0 and 1 so ... becomes zero
* if the range has size > 8 then lowest 3 bits all zeroed out

imagine the bit array object incrementing from m to n. We want to find out if there's a stable higher portion, but we may get a power-of-2 within the range, wiping out the stable...

We can convert m and n to two bit images. we can look at some examples below. we can compare the two bit images left to right to find the "higher portion" ( which would be null if po2 occurs). All lower bits are probably zeroed out in the result

10110101
10110100
10110011
10110010
10110001
-----
10110000

--shorter solution
compare m and n left to right. If m is shorter, then find the highest power-of-2 within the range. That bit image is probably the final result.

eg 1 to 1001

if same length, then compare left to right until a difference is found. Until that bit, all leftend bits are "retained".

--solution 1
1) determine if there are some power-of-2 within the range. If there is, then find the highest power-of-2. 
That bit pattern is probably the final result.
From now on let's suppose there's no power-of-2.

2) compare the two bit patterns m and n left to right to find the "stable higher portion"

Now focus on the lower portion. Look at the length of the range sz 

3) if sz is a power-of-2 like 8, then last 3 bits zero out and all other bits are in the stable portion.

4) suppose sz is between 8 and 16, then last 3 bits would zero out. Only need to work out the 4th bit. Just look at the 4th bit in m vs n

====Q[Lv]: Given array of integers, every element appears three times except for one, which appears exactly once. Find that single one in a linear runtime. Could you implement it without using extra memory?

well-defined problem:)
greedy?
O(1) space probably means swapping
mutable?
-- My O(N) algo {applicable for any-size integers and other than "three"}: Pick a random pivot and partition in O(N) time and O(1) space. Also keep track how many repetitions of the pivot value (probably 3). Exclude the pivot value, count size of both partitions and discard the one whose size=3X. Repeat.

====Q[L]: Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Rahul said there's an O(N) solution.

Sol2: O(N). use the O(N) algo in the blog on "given int array, find median ] O(N)". Then discard one of the two segments. Then repeat.

Sol2a: O(N) on average -- we get O(N)+O(N/2) + O(N/4) + ... < O(2N)

Use qsort partition algo to anchor a (random) pivot element. 

Note average complexity is acceptable in hashtable!

Sol2b: 
Instead of standard partition algo, we can pick two pivot (pivotL, pivotH) and anchor both in one scan. Then discard two of the three segments. Is this algorithmically better? I think so since we discard more irrelevant segments faster

====Q[L]: Given a string containing digits from 2-9 inclusive, return in any order all possible letter combinations (not permutations) that the number could represent.
====Q[c L]: sort a list in O(N logN) but constant space? 
I think swap is way to go, but recursion stack space? iterative?

This question is easy to search online.
====Q [c e v] insertion sort for array
====Q[c !e L]: Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
====Q [c !e] next split@N boys
====Q [c !e str] longest palindrome subsequence
====Q [c graph] find cycle in binary tree? See blog https://bintanvictor.wordpress.com/wp-admin/post.php?post=18950&action=edit
====Q [c] ring buffer
====Q SIG movie search in STL
============= problems below should be posted to blog
----
60% done Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2).... and look up the sum in a pre-populated hash table of M items.
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?
----
90% done Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
----
60% done Q [c e L tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run a lazy-dft to find the two paths-from-root. On each path, if we detect a cycle we terminate that path. As soon as we find the 2 paths we terminate DFT. 

On a given path need to check if we hit both nodes, so after finding one node we must go all the way to the leaf node or the other node.

IIF two CPUs are given, my dft will use two threads -- one left to right; the other right to left. This will more quickly locate the 2 target nodes if they appear near extremities.
