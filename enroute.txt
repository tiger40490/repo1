[c=classic]
[e=ez]
[g=github]
[L=leetcode]
[v=easy to verify]
Q Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return ALL such possible sentences. "Harder" than the punctuation problem.
recurse in a loop?

Q Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
just compute all pairs. For each pair, flip it and look for it in a hashtable.

Q [ev] Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Q [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
Q [cv] merge two sorted lists
Q [c e v] binary tree serialization #Deepak's solution
Q [c e v] insertion sort
Q [c !e] next split@N boys
Q [c !e str] longest palindrome subsequence
Q [c e tree] given 2 nodes in a tree, find the lowest common ancestor. https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
Just run dft to find the two paths-from-root
Q [Lv 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
Q [c graph] find cycle in binary tree? bft first.
Q [c] ring buffer
Q SIG movie search in STL
Q [c] hash table for single-threaded usage
Q [c] Ref counted string [[more eff c++]]
Q [L] max in sliding window Q (leetcode hard problem 239):Â Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position, return the max item in it... constant time.

analysis====

feature -- Note each item lives a fixed number of cycles. so insert/delete are both constrained.
feature -- Compare the min-stack. This is a min-queue..
idea -- Compare skyline problem.
idea -- sorted linked list with hm pointing to it for O(1) deletion. For insert? (i'm thinking of binary heap again.) I can efficiently insert above the highest (or 2nd highest) node, or below the lowest (or 2nd lowest).
idea -- can we use the sum?
idea -- fixed capacity binary heap -- is insertion faster than O(logN)?
--------------
Q [L] LFU (Least-Frequently-Used) cache to support the following operations: get and put in O(1)
* get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
* put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

ds -- centry i.e. CacheEntry node {key, value, hitCount, lastHit (timestamp), pointers to prev/next centries, (optional) ptr to host LinkNode}
* invariant: hitCount can only increase

ds -- inner list of centry nodes
* invariant: list sorted by lastHit. We can remove any node, but incoming node is always added to the Tail

ds -- fixed-sized (no rehash) hashtable {key -> ptr to centry}, 

ds -- LinkNode {level, inner list-of-centry, prev/next pointers } where all centry objects share the same hitCount denoted "level".
* invariant: outer list is always sorted by level

ds -- outer list of LinkNodes

when a centry gets a hit, its hitCount goes up. It bubbles up to the next higher LinkNode ((
* remove the centry from old linkNode, 
* append to new linkNode, at Tail of inner list. The new LinkNode could be empty or even non-existent
* optionally, new host linkNode's address is saved in the centry; 
))

Get() hit -- relatively easy. Update the hitCount and bubble up
Get() miss -- trivial
Update -- similar to get-hit
Insertion (after deletion) -- trivil.
Deletion -- always from list to hashtable, never the converse
* identify lowest LinkNode, then delete the head of inner list. O(1)
* when a linkNode becomes empty, it is removed from the outer list, to prevent build-up of consecutive empty LinkNodes leading to linear search for eviction target. Imagine aaaaa bbbbb c[need to evict]. Therefore, array of LinkNode is unacceptable

===== problems below should be posted to blog
