[c=classic]
[e=ez]
[g=github]
[L=leetcode]
[v=easy to verify]
Q Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return ALL such possible sentences. "Harder" than the punctuation problem.
recurse in a loop?

Q Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
just compute all pairs. For each pair, flip it and look for it in a hashtable.

Q [ev] Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Q [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
Q [cv] merge two sorted lists
Q [c e v] binary tree serialization #Deepak's solution
Q [c e v] insertion sort
Q [c !e] next split@N boys
Q [c !e str] longest palindrome subsequence
Q [c e tree] given 2 nodes in a tree, find the lowest common ancestor. https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
Just run dft to find the two paths-from-root
Q [Lv 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
Q [c graph] find cycle in binary tree? bft first.
Q [c] ring buffer
Q SIG movie search in STL
Q [c] hash table for single-threaded usage
Q [c] Ref counted string [[more eff c++]]
Q LFU (Least-Frequently-Used) cache to support the following operations: get and put in O(1)
* get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
* put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

ds -- centry i.e. CacheEntry {key, value, hitCount, lastHit, ptr to host LinkNode}
* invariant: hitCount can only increase
ds -- fixed-sized hashtable {key -> ptr to centry}, 
* Every time we remove from hashtable, we must also remove from list ((follow the ptr to the host linkNode, remove the centry from its hashset))
ds -- list of LinkNode {level, hashset of cacheEntry's, prev/next pointers } where all centry objects share the same hitCount == level.
* invariant: the list is always sorted by level

when a centry gets a hit, its hitCount goes up. It rellocates to another LinkNode ((removed from old linkNode, added to new linkNode, new host linkNode's address is saved in the centry ))

when a linkNode becomes empty, it is removed

===== problems below should be posted to blog

