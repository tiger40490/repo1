[c=classic]
[e=ez]
[g=github]
[L=leetcode]
[v=easy to verify]
Q Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.

Q Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Doable in O(NN)
just compute all pairs. For each pair, flip it and look for it in a hashtable.
%%A: separate into (M) non-negatives and (N) negatives. get pairs among negatives (N^2)...
Total O(NN + MM), smaller than O( [N+M]^2 )
test in leetcode?

Q [Lv] median@2lists -- given two pre-sorted arrays nums1 and nums2 of size m and n respectively, find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
Q [gv] reverse slist in k-groups. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
(No complexity requirement? I will aim for O(N) time and O(1) space.
%%A: first scan to count EOG (end of group) nodes. Say the last EOG is saved in a var "leog". In 2nd scan, we will adapt our non-recursive algo to reverse each K-group. When we hit leog, we exit.

Q [c e v] binary tree serialization #Deepak's solution
Q [c e v] insertion sort
Q [c !e] next split@N boys
Q [c !e str] longest palindrome subsequence
Q [c e tree] given 2 nodes (and root) of a binary tree, find the lowest common ancestor. A node can be a (direct/indirect) descendant of itself. All values are different. No uplink.
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
%%A: Just run a lazy-dft to find the two paths-from-root. On each path, if we detect a cycle we terminate that path. As soon as we find the 2 paths we terminate DFT. 

If two processors are given, my dft will use two threads -- one left to right; the other right to left. This will more quickly locate the 2 target nodes if they appear near extremities.

on a given path need to check if we hit both nodes, so after finding one node we must go all the way to leaf node

Q [Lv 2D] GO: Given a binary matrix, capture each 'o' region surrounded by 'X'. A region is captured by flipping all 'o's into 'X'. Boundary o's cannot be captured.
Q [c graph] find cycle in binary tree? bft first.
Q [c] ring buffer
Q SIG movie search in STL
Q [c] hash table for single-threaded usage
Q [c] Ref counted string [[more eff c++]]
Q [L] max in sliding window Q (leetcode hard problem 239):Â Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position, return the max item in it... constant time.

analysis====

feature -- Note each item lives a fixed number of cycles. so insert/delete are both constrained.
feature -- Compare the min-stack. This is a min-queue..
idea -- Compare skyline problem.
idea -- sorted linked list with hm pointing to it for O(1) deletion. For insert? (i'm thinking of binary heap again.) I can efficiently insert above the highest (or 2nd highest) node, or below the lowest (or 2nd lowest).
idea -- can we use the sum?
idea -- fixed capacity binary heap -- is insertion faster than O(logN)?
===== problems below should be posted to blog
