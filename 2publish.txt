--update blog on locking in notify() 
[[DougLea]] P233 points out that pthreads signal() doesn't require the lock being held

--update blog on binary semaphore #CSY (halo88)
[[DougLea]] P220 confirms that in some cases release() can increase the binary semaphore to beyond 2, destroying the mutual exclusion control.

However, java binary semaphore is a mutex because releasing a semaphore before aquiring has no effect

--update blog all-static java class
In [[DougLea]] P86, this foremost OO expert briefly noted that it can be best practice to replace a java singleton with an all-static class

--new blog lazy singleton bsed on JVM dynamic classloading (halo88)
In [[DougLea]] P86, this JVM expert pointed out that a simple "eager" singleton is eager in other language, but lazy in Java due to runtime on-demand class loading.

Specifically we mean a public[1] static final field. This initialization is thread-safe by default. Assuming the field is immediately accessed after class loading, this simple design is comparable to the familiar synchronized lazy singleton. What are the pros and cons? 

Synchronized singleton requires more legwork but 
* It lets you pass ctor parameters at runtime. Note the singleton ctor is private but getInstance(userInput) is possible.
* As hinted earlier, you may load the class but do not immediately use the instance, so the simple design incurs the expensive initialization cost too early.

[[DougLea]] ws writen before java5. With java5, [[EffJava]] advocates enum.

[1] DougLea actually prefers private with public getter, for encapsulation.

--new blog starting thread in ctor (halo88)
Q: is it good practice to call new Thread(..).start() in MyClass ctor?

I feel 30% confidence this blog has another post on this subject, to be combined.

P [[DougLea]] points out the potential danger of starting thread in a ctor, esp. if subclasses are beyond your control.

The visibility effect is equivalent to parent thread releasing an implicit lock and acquisition by the run() on new thread.

Frequently, the constructed MyClass instance is used by the new thread, but is MyClass fully constructed? It is if the new Thread(..).start() is last line in ctor, but what if this ctor runs as part of a subclass ctor? 

--new blog 3 fundamental constructs in java concurrency
The Doug Lea book is a classic. Published by the creator of java. [[Java Concurrency in Practice]] specifically says itself "is not an encyclopedic reference for All Things Concurrency for that, see Concurrent Programming in Java (Lea, 2000)"

Out of the 4 parts of this book, the last 3 are really about 
* synchronized keyword (and the Lock classes released after the books was written)
* wait/notify
* Thread class and Runnable

As such this book is centered around the "fundamental of fundamentals". Everything else in java concurrency is based on these 3 constructs. There's fundamentally no change to them in Java5,7,8,9 when I scanned through each "new feature lists"

I said "no change". Lockfree is one major addition, but it's not nearly as widely useful as these three. Lockfree is a viable alternative to locks in appropriate situations, but for many complex concurrent systems, locks are the only viable option.
--update blog on 3 big changes in SG dev job market
"conceding" market share.... Reson? .. Overall good news for me since my java arm is still stronger than c++ arm
5) no longer blue-collar -- programmer used to be blue-collar support staff for the revenue staff. Some of the companies listed above treat programmers as first-class citizens.
--update blog on touch screen
MSWE: finger zoom will cycle through the views: Details -> list -> small icons -> .. -> details
--new blog
2008 (GFC) peak OPRA msg rate
Wikipedia "low latency" ... 1 million updates per second. My NYSE parser can handle 370,000 messges per second per thread
--update blog:
keeping 2 passports together is not ideal. The old passport gets in the way when I frequently take out current passport. 
Perhaps keep old passport in pouch
--new blog: keep interview`:y rare]%%peers
Many of my peers acknowledge the importance of job interivews, but they are able to move up so they don't need to interview again and again.

Their model doesn't work for consultants.

Their model doesn't woork for non-leaders.

Their model is risky when they need to move out.

--new blog: criticalMass against churn 
See also post on impact of c++jobs

[tags t_gz_j^cpp, t_domainBet]

Critical mass (eg: in core java self-study) is one of the most effective strategies against technology churn. Once I accumulated the critical mass, I don't need a full time job to sustain it.

Q: how strongly is it related to accumulation?
A: not much AFTER you accumulate the critical mass. With java I did it through enough interviews and reading. 

Q: why some domains offer no critical mass?
A: some (jxee) have limited depth
A: some (TMP, py) have No pattern identified from interview questions

Q: how strongly is it related to leverage?
A: not much though Critical mass enhances leverage

..other examples of criticl mass against churn:
SQL? yes though SQL is diminishing
classic data structures? Yes
c++? yes took much longer to reach criticl mass
STL? yes
socket? not yet

