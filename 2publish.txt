--new blog Empty base-class optimiztion
This optmization only zeros out the runtime [1] size of baseclass subobject [2]. All other sizes of empty types are the same -- one byte.
   
Suppose Der subclasses B1 and B2.
Note on [1]:
If B1 is empty, then the compile-time operator sizeof() shows sizeof(B1) == 1 not zero, but at run time, the Der object size shows the B1 sub-object has zero size, due to EBCO.

Note on [2]:
If all of Der, B1 and B2 are empty, we know sizeof(Der) == 1, but how about rutime sizeof(an_Der_instance)? Also one, not zero, because this instance is not a baseclass subobject.

--new blog
shenzhen salary: RMB 350k/Y

--update blog: research .. why is rice pudding so delicious but moderate calorie? 
Is it due to low fat?
--new blog q[Node*] param can be..
A Node address can be an entire aray of Node objects
If the Node class has a nextNode field, then this param can represent a linked list, or head (or any node) of a linked list
If Node class has left and right child nodes, then this param can represent a tree, or root (or any other) node of a tree

Q: Can this param represent an array of linked lists? 
A: No. Since each payload (aka element) in the array is a Node*, then the array looks like a Node**

--update blog on locking in notify() 
[[DougLea]] P233 points out that pthreads signal() doesn't require the lock being held

--update blog on binary semaphore #CSY (halo88)
[[DougLea]] P220 confirms that in some cases release() can increase the binary semaphore to beyond 2, destroying the mutual exclusion control.

However, java binary semaphore is a mutex because releasing a semaphore before aquiring has no effect

--update blog all-static java class
In [[DougLea]] P86, this foremost OO expert briefly noted that it can be best practice to replace a java singleton with an all-static class

--new blog lazy singleton bsed on JVM dynamic classloading (halo88)
In [[DougLea]] P86, this JVM expert pointed out that a simple "eager" singleton is eager in other language, but lazy in Java due to runtime on-demand class loading.

Specifically we mean a public[1] static final field. This initialization is thread-safe by default. Assuming the field is immediately accessed after class loading, this simple design is comparable to the familiar synchronized lazy singleton. What are the pros and cons? 

Synchronized singleton requires more legwork but 
* It lets you pass ctor parameters at runtime. Note the singleton ctor is private but getInstance(userInput) is possible.
* As hinted earlier, you may load the class but do not immediately use the instance, so the simple design incurs the expensive initialization cost too early.

[[DougLea]] ws writen before java5. With java5, [[EffJava]] advocates enum.

[1] DougLea actually prefers private with public getter, for encapsulation.

--new blog starting thread in ctor (halo88)
Q: is it good practice to call new Thread(..).start() in MyClass ctor?

I feel 30% confidence this blog has another post on this subject, to be combined.

P [[DougLea]] points out the potential danger of starting thread in a ctor, esp. if subclasses are beyond your control.

The visibility effect is equivalent to parent thread releasing an implicit lock and acquisition by the run() on new thread.

Frequently, the constructed MyClass instance is used by the new thread, but is MyClass fully constructed? It is if the new Thread(..).start() is last line in ctor, but what if this ctor runs as part of a subclass ctor? 

--update blog on touch screen
MSWE: finger zoom will cycle through the views: Details -> list -> small icons -> .. -> details
--new blog
2008(GFC)peak OPRA msg rate
Wikipedia "low latency" article says ... 1 million updates per second. Note My NYSE parser can handle 370,000 messges per second per thread !
--update blog:
keeping 2 passports together is not ideal. The old passport gets in the way when I frequently take out current passport. 
Perhaps keep old passport in pouch
--new blog: keep interview`:y so rare with peers
Many of my peers acknowledge the importance of job interivews, but some of them are able to move up so they don't need to interview again and again.

Their model doesn't work for consultants.
Their model doesn't woork for non-leaders.
Their model is risky when they need to move out.
Their model is risky when they grow old.